
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>chaosmagpy.coordinate_utils &#8212; ChaosMagPy 0.11 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/nature.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/gallery.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/gallery-dataframe.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/gallery-rendered-html.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="nav-item nav-item-0"><a href="../../index.html">ChaosMagPy 0.11 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">chaosmagpy.coordinate_utils</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for chaosmagpy.coordinate_utils</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module provides functions related to coordinate transformations. Typical</span>
<span class="sd">coordinate reference frames and corresponding abbbreviations are listed in the</span>
<span class="sd">following.</span>

<span class="sd">**Abbreviations**</span>

<span class="sd">GEO : Geographic coordinate system (orthogonal)</span>
<span class="sd">    Geocentric coordinate system with the z-axis along Earth&#39;s rotation axis,</span>
<span class="sd">    x-axis pointing to Greenwich and y-axis completing the right-handed system.</span>
<span class="sd">    This is also referred to as the ECEF (Earth-centered Earth-fixed)</span>
<span class="sd">    coordinate system.</span>
<span class="sd">GG : Geodetic coordinate system (orthogonal).</span>
<span class="sd">    Earth is approximated by a spheroid (ellipsoid of revolution) with</span>
<span class="sd">    equatorial radius `a` and polar radius `b`, `b &lt; a`. The numerical values</span>
<span class="sd">    of these radii are defined by the World Geodetic System 1984 (WGS84).</span>
<span class="sd">USE : Cartesian coordinate system on spherical surface.</span>
<span class="sd">    Axes directions are defined as Up-South-East at a point of interest on the</span>
<span class="sd">    spherical surface (e.g. B_radius, B_theta, B_phi in spherical geocentric</span>
<span class="sd">    coordinates).</span>
<span class="sd">GSM : Geocentric Solar Magnetic coordinate system (orthogonal).</span>
<span class="sd">    With x-axis pointing towards the sun, y-axis perpendicular to plane spanned</span>
<span class="sd">    by Eart-Sun line and dipole axis and z-axis completing right-handed system.</span>
<span class="sd">SM : Solar Magnetic coordinate system (orthogonal)</span>
<span class="sd">    With z-axis along dipole axis pointing to the geomagnetic north pole,</span>
<span class="sd">    y-axis perpendicular to plane containing the dipole axis and the Earth-Sun</span>
<span class="sd">    line, and x-axis completing the right-handed system.</span>
<span class="sd">MAG : Magnetic coordinate system (centered dipole, orthogonal)</span>
<span class="sd">    With z-axis pointing to the geomagnetic north pole, x-axis in the plane</span>
<span class="sd">    spanned by the dipole axis and Earth&#39;s rotation axis, and y-axis completing</span>
<span class="sd">    the right-handed system.</span>

<span class="sd">.. autosummary::</span>
<span class="sd">    :toctree: functions</span>

<span class="sd">    igrf_dipole</span>
<span class="sd">    synth_rotate_gauss</span>
<span class="sd">    rotate_gauss_fft</span>
<span class="sd">    rotate_gauss</span>
<span class="sd">    sh_analysis</span>
<span class="sd">    sun_position</span>
<span class="sd">    zenith_angle</span>
<span class="sd">    spherical_to_cartesian</span>
<span class="sd">    cartesian_to_spherical</span>
<span class="sd">    basevectors_gsm</span>
<span class="sd">    basevectors_sm</span>
<span class="sd">    basevectors_use</span>
<span class="sd">    basevectors_mag</span>
<span class="sd">    geo_to_gg</span>
<span class="sd">    gg_to_geo</span>
<span class="sd">    geo_to_base</span>
<span class="sd">    matrix_geo_to_base</span>
<span class="sd">    transform_points</span>
<span class="sd">    transform_vectors</span>
<span class="sd">    center_azimuth</span>
<span class="sd">    local_time</span>
<span class="sd">    q_response</span>
<span class="sd">    q_response_1D</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">factorial</span>
<span class="kn">from</span> <span class="nn">chaosmagpy.model_utils</span> <span class="kn">import</span> <span class="n">legendre_poly</span>
<span class="kn">from</span> <span class="nn">chaosmagpy.config_utils</span> <span class="kn">import</span> <span class="n">basicConfig</span>

<span class="n">ROOT</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="vm">__file__</span><span class="p">))</span>


<div class="viewcode-block" id="igrf_dipole"><a class="viewcode-back" href="../../functions/chaosmagpy.coordinate_utils.igrf_dipole.html#chaosmagpy.coordinate_utils.igrf_dipole">[docs]</a><span class="k">def</span> <span class="nf">igrf_dipole</span><span class="p">(</span><span class="n">epoch</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute unit vector that is anti-parallel to the IGRF dipole.</span>

<span class="sd">    The vector points towards the geomagnetic north pole (located in the</span>
<span class="sd">    Northern Hemisphere).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    epoch : {&#39;2015&#39;, &#39;2010&#39;}, optional</span>
<span class="sd">        Epoch of IGRF-12 (2015) and IGRF-11 (2010). Epoch 2015 of IGRF-12 is</span>
<span class="sd">        used by default.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dipole : ndarray, shape (3,)</span>
<span class="sd">        Unit vector pointing to geomagnetic north pole (located in Northern</span>
<span class="sd">        Hemisphere).</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># default IGRF dipole</span>
    <span class="n">epoch</span> <span class="o">=</span> <span class="s1">&#39;2015&#39;</span> <span class="k">if</span> <span class="n">epoch</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">epoch</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">epoch</span> <span class="o">==</span> <span class="s1">&#39;2015&#39;</span><span class="p">:</span>
        <span class="c1"># IGRF-12 dipole coefficients, epoch 2015: theta = 9.69, phi = 287.37</span>
        <span class="n">dipole</span> <span class="o">=</span> <span class="n">_dipole_to_unit</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">29442.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1501.0</span><span class="p">,</span> <span class="mf">4797.1</span><span class="p">]))</span>

    <span class="k">elif</span> <span class="n">epoch</span> <span class="o">==</span> <span class="s1">&#39;2010&#39;</span><span class="p">:</span>
        <span class="c1"># dipole as used in original chaos software (IGRF-11), epoch 2010</span>
        <span class="n">dipole</span> <span class="o">=</span> <span class="n">_dipole_to_unit</span><span class="p">(</span><span class="mf">11.32</span><span class="p">,</span> <span class="mf">289.59</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Only epoch &quot;2010&quot; (IGRF-11) and&#39;</span>
                         <span class="s1">&#39;&quot;2015&quot; (IGRF-12) supported.&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dipole</span></div>


<span class="k">def</span> <span class="nf">_dipole_to_unit</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert degree-1 SH coefficients or geomagnetic north pole position to</span>
<span class="sd">    unit vector.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    *args</span>
<span class="sd">        Takes ``theta``, ``phi`` in degrees, ``[g10, g11, h11]`` or</span>
<span class="sd">        ``g10``, ``g11``, ``h11`` as input.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    vector : ndarray, shape (3,)</span>
<span class="sd">        Unit vector pointing to geomagnetic north pole.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># g11, h11, g10: dipole</span>
        <span class="c1"># unit vector, opposite to dipole</span>
        <span class="n">vector</span> <span class="o">=</span> <span class="o">-</span><span class="n">vector</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vector</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">),</span>
                           <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">),</span>
                           <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)])</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>  <span class="c1"># g11, h11, g10: dipole</span>
        <span class="c1"># unit vector, opposite to dipole</span>
        <span class="n">vector</span> <span class="o">=</span> <span class="o">-</span><span class="n">vector</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vector</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Only 1, 2 or 3 inputs accepted &#39;</span>
                         <span class="sa">f</span><span class="s1">&#39;but </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="si">}</span><span class="s1"> given.&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">vector</span>


<div class="viewcode-block" id="synth_rotate_gauss"><a class="viewcode-back" href="../../functions/chaosmagpy.coordinate_utils.synth_rotate_gauss.html#chaosmagpy.coordinate_utils.synth_rotate_gauss">[docs]</a><span class="k">def</span> <span class="nf">synth_rotate_gauss</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">frequency</span><span class="p">,</span> <span class="n">spectrum</span><span class="p">,</span> <span class="n">scaled</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute time-dependent matrices that transform spherical harmonic expansion</span>
<span class="sd">    from the given Fourier coefficients.</span>

<span class="sd">    The function computes matrices that transform the spherical harmonic</span>
<span class="sd">    expansion of a time-dependent reference system (e.g. GSM, SM) to GEO using</span>
<span class="sd">    Fourier expansion of the transformation coefficients.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    time : ndarray, shape (...)</span>
<span class="sd">        Time given as modified Julian date, i.e. with respect to the date 0h00</span>
<span class="sd">        January 1, 2000 (mjd2000).</span>
<span class="sd">    frequency : ndarray, shape (k,) or (k, m, n)</span>
<span class="sd">        Vector of positive frequencies given in oscillations per day.</span>
<span class="sd">    spectrum : ndarray, shape (k, m, n)</span>
<span class="sd">        Fourier components of the matrices (reside in the last two dimensions).</span>
<span class="sd">    scaled : bool, optional (defaults to ``False``)</span>
<span class="sd">        If ``True``, the function expects `scaled` Fourier coefficients, i.e.</span>
<span class="sd">        the non-bias term (all non-zero frequency terms) have been multiplied</span>
<span class="sd">        by a factor of 2. Hence, taking the real part of the spectrum</span>
<span class="sd">        multiplied with the complex exponentials results in the correctly</span>
<span class="sd">        scaled and time-shifted real-valued harmonics.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    matrix : ndarray, shape (..., m, n)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">scaled</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">scaled</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">time</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">frequency</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">frequency</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">frequency</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">frequency</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">spectrum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">spectrum</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>

    <span class="c1"># output of shape (..., k, n, m)</span>
    <span class="n">freq_t</span> <span class="o">=</span> <span class="n">frequency</span><span class="o">*</span><span class="n">time</span>

    <span class="c1"># compute complex exponentials</span>
    <span class="n">harmonics</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">freq_t</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">harmonics</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">freq_t</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">freq_t</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">scaled</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
        <span class="c1"># scale non-offset coefficients by 2 before synthesizing matrices</span>
        <span class="n">harmonics</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">frequency</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">harmonics</span><span class="p">,</span> <span class="n">harmonics</span><span class="p">)</span>

    <span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">spectrum</span><span class="o">*</span><span class="n">harmonics</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">3</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span></div>


<div class="viewcode-block" id="rotate_gauss_fft"><a class="viewcode-back" href="../../functions/chaosmagpy.coordinate_utils.rotate_gauss_fft.html#chaosmagpy.coordinate_utils.rotate_gauss_fft">[docs]</a><span class="k">def</span> <span class="nf">rotate_gauss_fft</span><span class="p">(</span><span class="n">nmax</span><span class="p">,</span> <span class="n">kmax</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">qfunc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">filter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">save_to</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reference</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scaled</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">start_date</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute Fourier coefficients of the timeseries of matrices that transform</span>
<span class="sd">    spherical harmonic expansions (degree ``kmax``) from a time-dependent</span>
<span class="sd">    reference system (GSM, SM) to GEO (degree ``nmax``).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nmax : int</span>
<span class="sd">        Maximum degree of spherical harmonic expansion with respect to</span>
<span class="sd">        geographic reference (target reference system).</span>
<span class="sd">    kmax : int</span>
<span class="sd">        Maximum degree of spherical harmonic expansion with respect to rotated</span>
<span class="sd">        reference system.</span>
<span class="sd">    qfunc : callable</span>
<span class="sd">        Callable ``q = qfunc(freq, k)`` that returns the complex q-response</span>
<span class="sd">        ``q`` (ndarray, shape (``N``,)) given a frequency vector ``freq``</span>
<span class="sd">        (ndarray, shape (``N``,)) in (1/sec) and the index ``k`` (int) counting</span>
<span class="sd">        the Gauss coefficients in natural order, i.e. ``k = 0`` is</span>
<span class="sd">        :math:`g_1^0`, ``k = 1`` is :math:`g_1^1`, ``k = 2`` is :math:`h_1^1`</span>
<span class="sd">        and so on.</span>
<span class="sd">    step : float</span>
<span class="sd">        Sample spacing given in hours (default is 1.0 hour).</span>
<span class="sd">    N : int, optional</span>
<span class="sd">        Number of samples for which to evaluate the FFT (default is</span>
<span class="sd">        N = 8*365.25*24 equiv. to 8 years using default sample spacing).</span>
<span class="sd">    filter : int, optional</span>
<span class="sd">        Set filter length, i.e. number of Fourier coefficients to be saved</span>
<span class="sd">        (default is ``int(N/2+1)``).</span>
<span class="sd">    save_to : str, optional</span>
<span class="sd">        Path and file name to store output in npz-format. Defaults to</span>
<span class="sd">        ``False``, i.e. no file is written.</span>
<span class="sd">    reference : {&#39;gsm&#39;, &#39;sm&#39;}, optional</span>
<span class="sd">        Time-dependent reference system (default is GSM).</span>
<span class="sd">    scaled : bool, optional (default is ``False``)</span>
<span class="sd">        If ``True``, the function returns `scaled` Fourier coefficients, i.e.</span>
<span class="sd">        the non-bias terms (all non-zero frequency terms) are multiplied by a</span>
<span class="sd">        factor of 2. Hence, taking the real part of the first half of the</span>
<span class="sd">        spectrum multiplied with the complex exponentials results in the</span>
<span class="sd">        correctly scaled and time-shifted real-valued harmonics.</span>
<span class="sd">    start_date : float, optional (defaults to ``0.0``, i.e. Jan 1, 2000)</span>
<span class="sd">        Time point from which to compute the time series of coefficient</span>
<span class="sd">        matrices in modified Julian date.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    frequency, spectrum, frequency_ind, spectrum_ind : ndarray, \</span>
<span class="sd">shape (``filter``, ``nmax`` (``nmax`` + 2), ``kmax`` (``kmax`` + 2))</span>
<span class="sd">        Unsorted vector of positive frequencies in 1/days and complex fourier</span>
<span class="sd">        spectrum of rotation matrices to transform spherical</span>
<span class="sd">        harmonic expansions.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If ``save_to=&lt;filepath&gt;``, then an ``*.npz``-file is written with the</span>
<span class="sd">    keywords {&#39;frequency&#39;, &#39;spectrum&#39;, &#39;frequency_ind&#39;, &#39;spectrum_ind&#39;, ...}</span>
<span class="sd">    and all the possible keywords. Among them, ``&#39;dipole&#39;`` means the three</span>
<span class="sd">    spherical harmonic coefficients of the dipole set in</span>
<span class="sd">    ``basicConfig[&#39;params.dipole&#39;]``.</span>

<span class="sd">    About the discrete Fourier transform (DFT) used here:</span>

<span class="sd">    A discrete periodic signal :math:`x[n]` with :math:`n\\in [0, N-1]`</span>
<span class="sd">    (period of `N`) is represented in terms of complex-exponentials as</span>

<span class="sd">    .. math::</span>

<span class="sd">       x[n] = \\sum_{k=0}^{N-1}X[k]w_N^{kn}, \\qquad w_N = \\exp(i 2\\pi/N)</span>

<span class="sd">    Here, :math:`X[k]`, :math:`k\\in [0, N-1]` is the Fourier transform of</span>
<span class="sd">    :math:`x[n]`. The DFT is defined as:</span>

<span class="sd">    .. math::</span>

<span class="sd">       X[k] = \\frac{1}{N}\\sum_{n=0}^{N-1}x[n]w_N^{-kn}</span>

<span class="sd">    In ``numpy``, this operation is implemented with</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">       import numpy as np</span>

<span class="sd">       X = np.fft.fft(x) / N</span>

<span class="sd">    Finally, if ``save_to`` is given, only half of the Fourier coefficients</span>
<span class="sd">    ``X[0:int(N/2)+1]`` (right-exclusive) are saved (or less if ``filter`` is</span>
<span class="sd">    specified).</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">reference</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">reference</span> <span class="o">=</span> <span class="s1">&#39;gsm&#39;</span>

    <span class="k">if</span> <span class="n">step</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">step</span> <span class="o">=</span> <span class="mf">1.0</span>  <span class="c1"># sample spacing of one hour</span>

    <span class="k">if</span> <span class="n">N</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="mf">365.25</span><span class="o">*</span><span class="mi">24</span><span class="p">)</span>  <span class="c1"># number of samples</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">filter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># number of significant Fourier components to be saved</span>
        <span class="nb">filter</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">N</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="nb">filter</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">filter</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">save_to</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">save_to</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># do not write output file</span>

    <span class="k">if</span> <span class="n">scaled</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">scaled</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="n">start_date</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">start_date</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">*</span> <span class="n">step</span> <span class="o">/</span> <span class="mf">24.</span> <span class="o">+</span> <span class="n">start_date</span>  <span class="c1"># time in days</span>

    <span class="c1"># compute base vectors of time-dependent reference system</span>
    <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">reference</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;gsm&#39;</span><span class="p">:</span>
        <span class="n">base_1</span><span class="p">,</span> <span class="n">base_2</span><span class="p">,</span> <span class="n">base_3</span> <span class="o">=</span> <span class="n">basevectors_gsm</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">str</span><span class="p">(</span><span class="n">reference</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;sm&#39;</span><span class="p">:</span>
        <span class="n">base_1</span><span class="p">,</span> <span class="n">base_2</span><span class="p">,</span> <span class="n">base_3</span> <span class="o">=</span> <span class="n">basevectors_sm</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Reference system must be either &quot;GSM&quot; or &quot;SM&quot;.&#39;</span><span class="p">)</span>

    <span class="c1"># predefine output matrices, last dimension runs through time</span>
    <span class="n">matrix_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="n">nmax</span><span class="o">*</span><span class="p">(</span><span class="n">nmax</span><span class="o">+</span><span class="mi">2</span><span class="p">),</span> <span class="n">kmax</span><span class="o">*</span><span class="p">(</span><span class="n">kmax</span><span class="o">+</span><span class="mi">2</span><span class="p">)))</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Calculating Gauss rotation matrices for </span><span class="si">{:}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
        <span class="n">reference</span><span class="o">.</span><span class="n">upper</span><span class="p">()))</span>

    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="c1"># compute transformation matrix: reference to geographic system</span>
        <span class="n">matrix_time</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">rotate_gauss</span><span class="p">(</span>
            <span class="n">nmax</span><span class="p">,</span> <span class="n">kmax</span><span class="p">,</span> <span class="n">base_1</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">base_2</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">base_3</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Finished </span><span class="si">{:.1f}</span><span class="s2">%&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">((</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">N</span><span class="o">*</span><span class="mi">100</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\r</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

    <span class="c1"># DFT and proper scaling</span>
    <span class="n">spectrum_full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">matrix_time</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">N</span>
    <span class="n">spectrum_full</span> <span class="o">=</span> <span class="n">spectrum_full</span><span class="p">[:</span><span class="nb">int</span><span class="p">(</span><span class="n">N</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>  <span class="c1"># remove aliases</span>

    <span class="c1"># oscillations per second</span>
    <span class="n">frequency_full</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">N</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="n">N</span><span class="p">)</span> <span class="o">/</span> <span class="n">step</span> <span class="o">/</span> <span class="mi">3600</span>

    <span class="k">if</span> <span class="n">qfunc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># compute q-response and keep in memory</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">q_response</span><span class="p">(</span><span class="n">frequency_full</span><span class="p">,</span> <span class="n">nmax</span><span class="p">)</span>

        <span class="c1"># now define qfunc here</span>
        <span class="k">def</span> <span class="nf">qfunc</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
            <span class="c1"># index of degree in response</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">q</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>

    <span class="c1"># predefine output arrays</span>
    <span class="n">frequency</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">filter</span><span class="p">,</span> <span class="n">nmax</span><span class="o">*</span><span class="p">(</span><span class="n">nmax</span><span class="o">+</span><span class="mi">2</span><span class="p">),</span> <span class="n">kmax</span><span class="o">*</span><span class="p">(</span><span class="n">kmax</span><span class="o">+</span><span class="mi">2</span><span class="p">)))</span>
    <span class="n">frequency_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">filter</span><span class="p">,</span> <span class="n">nmax</span><span class="o">*</span><span class="p">(</span><span class="n">nmax</span><span class="o">+</span><span class="mi">2</span><span class="p">),</span> <span class="n">kmax</span><span class="o">*</span><span class="p">(</span><span class="n">kmax</span><span class="o">+</span><span class="mi">2</span><span class="p">)))</span>
    <span class="n">spectrum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">filter</span><span class="p">,</span> <span class="n">nmax</span><span class="o">*</span><span class="p">(</span><span class="n">nmax</span><span class="o">+</span><span class="mi">2</span><span class="p">),</span> <span class="n">kmax</span><span class="o">*</span><span class="p">(</span><span class="n">kmax</span><span class="o">+</span><span class="mi">2</span><span class="p">)),</span>
                        <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">spectrum_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">filter</span><span class="p">,</span> <span class="n">nmax</span><span class="o">*</span><span class="p">(</span><span class="n">nmax</span><span class="o">+</span><span class="mi">2</span><span class="p">),</span> <span class="n">kmax</span><span class="o">*</span><span class="p">(</span><span class="n">kmax</span><span class="o">+</span><span class="mi">2</span><span class="p">)),</span>
                            <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nmax</span><span class="o">*</span><span class="p">(</span><span class="n">nmax</span><span class="o">+</span><span class="mi">2</span><span class="p">)):</span>

        <span class="c1"># compute Q-response for freqencies and given Gauss coefficient</span>
        <span class="n">response</span> <span class="o">=</span> <span class="n">qfunc</span><span class="p">(</span><span class="n">frequency_full</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">kmax</span><span class="o">*</span><span class="p">(</span><span class="n">kmax</span><span class="o">+</span><span class="mi">2</span><span class="p">)):</span>
            <span class="c1"># select specific Fourier coefficients from the rotation matrix</span>
            <span class="n">element</span> <span class="o">=</span> <span class="n">spectrum_full</span><span class="p">[:,</span> <span class="n">k</span><span class="p">,</span> <span class="n">l</span><span class="p">]</span>

            <span class="c1"># modify Fourier components with Q-response</span>
            <span class="n">element_ind</span> <span class="o">=</span> <span class="n">response</span><span class="o">*</span><span class="n">element</span>

            <span class="c1"># index of sorted element spectrum (descending order)</span>
            <span class="n">sort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">element</span><span class="p">))[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">sort</span> <span class="o">=</span> <span class="n">sort</span><span class="p">[:</span><span class="nb">filter</span><span class="p">]</span>  <span class="c1"># only keep small number of components</span>

            <span class="c1"># index of sorted element spectrum (descending order)</span>
            <span class="n">sort_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">element_ind</span><span class="p">))[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">sort_ind</span> <span class="o">=</span> <span class="n">sort_ind</span><span class="p">[:</span><span class="nb">filter</span><span class="p">]</span>  <span class="c1"># only keep small number</span>

            <span class="c1"># write sorted frequency (per day) and fourier components to array</span>
            <span class="n">frequency</span><span class="p">[:,</span> <span class="n">k</span><span class="p">,</span> <span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">frequency_full</span><span class="p">[</span><span class="n">sort</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">24</span><span class="o">*</span><span class="mi">3600</span><span class="p">)</span>
            <span class="n">frequency_ind</span><span class="p">[:,</span> <span class="n">k</span><span class="p">,</span> <span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">frequency_full</span><span class="p">[</span><span class="n">sort_ind</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">24</span><span class="o">*</span><span class="mi">3600</span><span class="p">)</span>
            <span class="n">spectrum</span><span class="p">[:,</span> <span class="n">k</span><span class="p">,</span> <span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">element</span><span class="p">[</span><span class="n">sort</span><span class="p">]</span>
            <span class="n">spectrum_ind</span><span class="p">[:,</span> <span class="n">k</span><span class="p">,</span> <span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">element_ind</span><span class="p">[</span><span class="n">sort_ind</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">scaled</span><span class="p">:</span>
        <span class="c1"># scale non-offset coefficients by 2</span>
        <span class="n">spectrum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">frequency</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">spectrum</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">spectrum</span><span class="p">)</span>
        <span class="n">spectrum_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">frequency_ind</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">spectrum_ind</span><span class="p">,</span>
                                <span class="mi">2</span><span class="o">*</span><span class="n">spectrum_ind</span><span class="p">)</span>

    <span class="c1"># save several arrays to binary</span>
    <span class="k">if</span> <span class="n">save_to</span><span class="p">:</span>
        <span class="n">np</span><span class="o">.</span><span class="n">savez</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">save_to</span><span class="p">),</span>
                 <span class="n">frequency</span><span class="o">=</span><span class="n">frequency</span><span class="p">,</span> <span class="n">spectrum</span><span class="o">=</span><span class="n">spectrum</span><span class="p">,</span>
                 <span class="n">frequency_ind</span><span class="o">=</span><span class="n">frequency_ind</span><span class="p">,</span> <span class="n">spectrum_ind</span><span class="o">=</span><span class="n">spectrum_ind</span><span class="p">,</span>
                 <span class="n">step</span><span class="o">=</span><span class="n">step</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="n">N</span><span class="p">,</span> <span class="nb">filter</span><span class="o">=</span><span class="nb">filter</span><span class="p">,</span> <span class="n">reference</span><span class="o">=</span><span class="n">reference</span><span class="p">,</span>
                 <span class="n">scaled</span><span class="o">=</span><span class="n">scaled</span><span class="p">,</span> <span class="n">dipole</span><span class="o">=</span><span class="n">basicConfig</span><span class="p">[</span><span class="s1">&#39;params.dipole&#39;</span><span class="p">],</span>
                 <span class="n">start_date</span><span class="o">=</span><span class="n">start_date</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Output saved to </span><span class="si">{:}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">save_to</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">frequency</span><span class="p">,</span> <span class="n">spectrum</span><span class="p">,</span> <span class="n">frequency_ind</span><span class="p">,</span> <span class="n">spectrum_ind</span></div>


<div class="viewcode-block" id="rotate_gauss"><a class="viewcode-back" href="../../functions/chaosmagpy.coordinate_utils.rotate_gauss.html#chaosmagpy.coordinate_utils.rotate_gauss">[docs]</a><span class="k">def</span> <span class="nf">rotate_gauss</span><span class="p">(</span><span class="n">nmax</span><span class="p">,</span> <span class="n">kmax</span><span class="p">,</span> <span class="n">base_1</span><span class="p">,</span> <span class="n">base_2</span><span class="p">,</span> <span class="n">base_3</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute matrices for the coordinate transformation of spherical harmonic</span>
<span class="sd">    expansions.</span>

<span class="sd">    Transform the spherical harmonic expansion in terms of rotated geocentric</span>
<span class="sd">    spherical coordinates (e.g. GSM) to the spherical harmonic expansion</span>
<span class="sd">    in terms of the standard geographic coordinate system (GEO). The rotated</span>
<span class="sd">    coordinate system is described by 3 orthogonal base vectors with components</span>
<span class="sd">    in GEO coordinates.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nmax : int</span>
<span class="sd">        Maximum degree of spherical harmonic expansion with respect to</span>
<span class="sd">        geographic reference (target reference system).</span>
<span class="sd">    kmax : int</span>
<span class="sd">        Maximum degree of spherical harmonic expansion with respect to rotated</span>
<span class="sd">        reference system.</span>
<span class="sd">    base_1, base_2, base_3 : ndarray, shape (..., 3)</span>
<span class="sd">        Base vectors of rotated reference system given in terms of the</span>
<span class="sd">        target reference system. Vectors reside in the last dimension. The base</span>
<span class="sd">        vectors are needed for the coordinate transformation.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    matrix : ndarray, shape (..., ``nmax`` (``nmax`` + 2), ``kmax`` \</span>
<span class="sd">(``kmax`` + 2))</span>
<span class="sd">        Matrices reside in last two dimensions. They transform spherical</span>
<span class="sd">        harmonic coefficients of rotated reference (e.g. GSM) to standard</span>
<span class="sd">        geographic reference (GEO):</span>

<span class="sd">        [g10 g11 h11 ...]_geo = M * [g10 g11 h11 ...]_gsm</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">assert</span> <span class="p">(</span><span class="n">base_1</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">base_2</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">base_1</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">base_3</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">time_shape</span> <span class="o">=</span> <span class="n">base_1</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># retain original shape of grid</span>

    <span class="c1"># predefine output array</span>
    <span class="n">matrix_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">time_shape</span> <span class="o">+</span> <span class="p">(</span><span class="n">nmax</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">nmax</span><span class="p">,</span> <span class="n">kmax</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">kmax</span><span class="p">))</span>

    <span class="c1"># define Gauss-Legendre grid for surface integration</span>
    <span class="n">n_theta</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">nmax</span> <span class="o">+</span> <span class="n">kmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># number of points in colatitude</span>
    <span class="n">n_phi</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">n_theta</span>  <span class="c1"># number of points in azimuth</span>

    <span class="c1"># integrates polynomials of degree 2*n_theta-1 exactly</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polynomial</span><span class="o">.</span><span class="n">legendre</span><span class="o">.</span><span class="n">leggauss</span><span class="p">(</span><span class="n">n_theta</span><span class="p">)</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">/</span><span class="n">n_phi</span>

    <span class="c1"># compute Schmidt quasi-normalized associated Legendre functions and</span>
    <span class="c1"># corresponding normalization</span>
    <span class="n">Pnm</span> <span class="o">=</span> <span class="n">legendre_poly</span><span class="p">(</span><span class="n">nmax</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>
    <span class="n">n_Pnm</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">nmax</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="n">nmax</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n_Pnm</span><span class="p">,))</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nmax</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">lower</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">n</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">n</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">upper</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">n</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="n">n</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">norm</span><span class="p">[</span><span class="n">lower</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># inner product of Pn0</span>
        <span class="n">norm</span><span class="p">[</span><span class="n">lower</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">upper</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># inner product of Pnm m&gt;0</span>

    <span class="c1"># generate grid of rotated reference system</span>
    <span class="n">phi_grid</span><span class="p">,</span> <span class="n">theta_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>

    <span class="c1"># run over time index and produce matrix for every point in time</span>
    <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndindex</span><span class="p">(</span><span class="n">time_shape</span><span class="p">):</span>

        <span class="c1"># predefine array size for each point in time</span>
        <span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nmax</span><span class="o">*</span><span class="p">(</span><span class="n">nmax</span><span class="o">+</span><span class="mi">2</span><span class="p">),</span> <span class="n">kmax</span><span class="o">*</span><span class="p">(</span><span class="n">kmax</span><span class="o">+</span><span class="mi">2</span><span class="p">)))</span>

        <span class="n">theta_ref</span><span class="p">,</span> <span class="n">phi_ref</span> <span class="o">=</span> <span class="n">geo_to_base</span><span class="p">(</span>
            <span class="n">theta_grid</span><span class="p">,</span> <span class="n">phi_grid</span><span class="p">,</span> <span class="n">base_1</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">base_2</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">base_3</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>

        <span class="c1"># compute Schmidt quasi-normalized associated Legendre functions on</span>
        <span class="c1"># grid in rotated reference system: theta_ref, phi_ref</span>
        <span class="n">Pnm_ref</span> <span class="o">=</span> <span class="n">legendre_poly</span><span class="p">(</span><span class="n">kmax</span><span class="p">,</span> <span class="n">theta_ref</span><span class="p">)</span>

        <span class="c1"># compute powers of complex exponentials</span>
        <span class="n">nphi_ref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">kmax</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">phi_ref</span><span class="p">))</span>
        <span class="n">exp_ref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">nphi_ref</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">nphi_ref</span><span class="p">)</span>

        <span class="c1"># loop over columns of matrix</span>
        <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># index of column</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">kmax</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>

            <span class="c1"># l = 0</span>
            <span class="n">sh_ref</span> <span class="o">=</span> <span class="n">Pnm_ref</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">exp_ref</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># cplx spherical harmonic</span>
            <span class="n">fft_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">sh_ref</span><span class="o">.</span><span class="n">real</span><span class="p">)</span> <span class="o">/</span> <span class="n">n_phi</span>  <span class="c1"># only real part non-zero</span>

            <span class="c1"># SH analysis: write column of matrix, row by row</span>
            <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># index of row</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nmax</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>

                <span class="n">lower</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">n</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">n</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># index for Pnm norm</span>

                <span class="c1">#  m = 0: colatitude integration using Gauss weights</span>
                <span class="n">coeff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">fft_c</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">Pnm</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">weights</span><span class="p">)</span> <span class="o">/</span> <span class="n">norm</span><span class="p">[</span><span class="n">lower</span><span class="p">]</span>
                <span class="n">matrix</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">coeff</span><span class="o">.</span><span class="n">real</span>
                <span class="n">row</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="c1"># m &gt; 0</span>
                <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                    <span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">fft_c</span><span class="p">[:,</span> <span class="n">m</span><span class="p">]</span><span class="o">*</span><span class="n">Pnm</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span><span class="o">*</span><span class="n">weights</span><span class="p">)</span> <span class="o">/</span>
                             <span class="n">norm</span><span class="p">[</span><span class="n">lower</span><span class="o">+</span><span class="n">m</span><span class="p">])</span>
                    <span class="n">matrix</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">coeff</span><span class="o">.</span><span class="n">real</span>
                    <span class="n">matrix</span><span class="p">[</span><span class="n">row</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">coeff</span><span class="o">.</span><span class="n">imag</span>
                    <span class="n">row</span> <span class="o">+=</span> <span class="mi">2</span>

            <span class="n">col</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># update index of column</span>

            <span class="c1"># l &gt; 0</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">sh_ref</span> <span class="o">=</span> <span class="n">Pnm_ref</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">l</span><span class="p">]</span><span class="o">*</span><span class="n">exp_ref</span><span class="p">[</span><span class="n">l</span><span class="p">]</span>
                <span class="n">fft_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">sh_ref</span><span class="o">.</span><span class="n">real</span><span class="p">)</span> <span class="o">/</span> <span class="n">n_phi</span>
                <span class="n">fft_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">sh_ref</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span> <span class="o">/</span> <span class="n">n_phi</span>

                <span class="c1"># SH analysis: write column of R, row by row</span>
                <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># index of row</span>
                <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nmax</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>

                    <span class="n">lower</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">n</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">n</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># index for Pnm norm</span>

                    <span class="c1"># cosine part</span>
                    <span class="n">coeff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">fft_c</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">Pnm</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">weights</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">[</span><span class="n">lower</span><span class="p">]</span>
                    <span class="n">matrix</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">coeff</span><span class="o">.</span><span class="n">real</span>

                    <span class="c1"># sine part</span>
                    <span class="n">coeff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">fft_s</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">Pnm</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">weights</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">[</span><span class="n">lower</span><span class="p">]</span>
                    <span class="n">matrix</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">coeff</span><span class="o">.</span><span class="n">real</span>

                    <span class="n">row</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># update row index</span>

                    <span class="c1"># m &gt; 0</span>
                    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                        <span class="c1"># cosine part</span>
                        <span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">fft_c</span><span class="p">[:,</span> <span class="n">m</span><span class="p">]</span><span class="o">*</span><span class="n">Pnm</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span><span class="o">*</span><span class="n">weights</span><span class="p">)</span> <span class="o">/</span>
                                 <span class="n">norm</span><span class="p">[</span><span class="n">lower</span><span class="o">+</span><span class="n">m</span><span class="p">])</span>
                        <span class="n">matrix</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">coeff</span><span class="o">.</span><span class="n">real</span>
                        <span class="n">matrix</span><span class="p">[</span><span class="n">row</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">coeff</span><span class="o">.</span><span class="n">imag</span>

                        <span class="c1"># sine part</span>
                        <span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">fft_s</span><span class="p">[:,</span> <span class="n">m</span><span class="p">]</span><span class="o">*</span><span class="n">Pnm</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span><span class="o">*</span><span class="n">weights</span><span class="p">)</span> <span class="o">/</span>
                                 <span class="n">norm</span><span class="p">[</span><span class="n">lower</span><span class="o">+</span><span class="n">m</span><span class="p">])</span>
                        <span class="n">matrix</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">coeff</span><span class="o">.</span><span class="n">real</span>
                        <span class="n">matrix</span><span class="p">[</span><span class="n">row</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">col</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">coeff</span><span class="o">.</span><span class="n">imag</span>

                        <span class="n">row</span> <span class="o">+=</span> <span class="mi">2</span>  <span class="c1"># update row index</span>

                <span class="n">col</span> <span class="o">+=</span> <span class="mi">2</span>  <span class="c1"># update column index</span>

        <span class="n">matrix_time</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">matrix</span>  <span class="c1"># write rotation matrix into output</span>

    <span class="k">return</span> <span class="n">matrix_time</span></div>


<div class="viewcode-block" id="sh_analysis"><a class="viewcode-back" href="../../functions/chaosmagpy.coordinate_utils.sh_analysis.html#chaosmagpy.coordinate_utils.sh_analysis">[docs]</a><span class="k">def</span> <span class="nf">sh_analysis</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">nmax</span><span class="p">,</span> <span class="n">kmax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform a spherical harmonic expansion of a function defined on a</span>
<span class="sd">    spherical surface.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    func: callable</span>
<span class="sd">        Function takes two inputs: colatitude in degrees and longitude in</span>
<span class="sd">        degrees. The function must accept 2-D arrays and preserve shapes.</span>
<span class="sd">    nmax: int</span>
<span class="sd">        Maximum spherical harmonic degree of the expansion.</span>
<span class="sd">    kmax: int, optional, greater than or equal to nmax</span>
<span class="sd">        Maximum spherical harmonic degree needed to resolve the output of</span>
<span class="sd">        ``func``. This basically increases the number of points in colatitude,</span>
<span class="sd">        which improves the accuracy of the numerical integration</span>
<span class="sd">        (defaults to ``nmax``). Ignored if ``kmax &lt; nmax``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    coeffs: ndarray, shape (nmax*(nmax+2),)</span>
<span class="sd">        Coefficients of the spherical harmonic expansion.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    First, a straight forward example using the spherical harmonic</span>
<span class="sd">    :math:`Y_1^1`:</span>

<span class="sd">    &gt;&gt;&gt; import chaosmagpy as cp</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; #</span>
<span class="sd">    &gt;&gt;&gt; def func(theta, phi):</span>
<span class="sd">    &gt;&gt;&gt;     n, m = 1, 1</span>
<span class="sd">    &gt;&gt;&gt;     Pnm = cp.coordinate_utils.legendre_poly(n, theta)</span>
<span class="sd">    &gt;&gt;&gt;     if m &gt;= 0:</span>
<span class="sd">    &gt;&gt;&gt;         return np.cos(m*np.radians(phi))*Pnm[n, m]</span>
<span class="sd">    &gt;&gt;&gt;     else:</span>
<span class="sd">    &gt;&gt;&gt;         return np.sin(abs(m)*np.radians(phi))*Pnm[n, abs(m)]</span>

<span class="sd">    &gt;&gt;&gt; cp.coordinate_utils.sh_analysis(func, nmax=1)</span>
<span class="sd">        array([0.0000000e+00, 1.0000000e+00, 1.2246468e-16])</span>

<span class="sd">    Now, an example where the numerical integration is not sufficiently</span>
<span class="sd">    accurate:</span>

<span class="sd">    &gt;&gt;&gt; def func(theta, phi):</span>
<span class="sd">    &gt;&gt;&gt;     n, m = 7, 0  # increased degree to n=7</span>
<span class="sd">    &gt;&gt;&gt;     Pnm = cp.coordinate_utils.legendre_poly(n, theta)</span>
<span class="sd">    &gt;&gt;&gt;     return Pnm[n, m]</span>

<span class="sd">    &gt;&gt;&gt; cp.coordinate_utils.sh_analysis(func, nmax=1)</span>
<span class="sd">        array([0.55555556, 0.00000000e+00, 0.00000000e+00])  # g10 is wrong</span>

<span class="sd">    But, by setting ``kmax=7`` and, thus, increasing the number of integration</span>
<span class="sd">    points:</span>

<span class="sd">    &gt;&gt;&gt; cp.coordinate_utils.sh_analysis(func, nmax=1, kmax=7)</span>
<span class="sd">        array([-1.14491749e-16, 0.00000000e+00, -0.00000000e+00])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">kmax</span> <span class="o">=</span> <span class="n">nmax</span> <span class="k">if</span> <span class="n">kmax</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">kmax</span><span class="p">)</span>

    <span class="c1"># define Gauss-Legendre grid for surface integration,</span>
    <span class="c1"># quadrature integrates polynomials of degree (2*n_theta - 1) exactly,</span>
    <span class="c1"># here the integrands are Pnm(x)*Pkl(x), hence of degree = 2nmax</span>
    <span class="n">n_theta</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">nmax</span><span class="p">,</span> <span class="n">kmax</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># number of points in colatitude</span>
    <span class="n">n_phi</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">n_theta</span>  <span class="c1"># number of points in azimuth</span>

    <span class="n">x</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polynomial</span><span class="o">.</span><span class="n">legendre</span><span class="o">.</span><span class="n">leggauss</span><span class="p">(</span><span class="n">n_theta</span><span class="p">)</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">/</span><span class="n">n_phi</span>

    <span class="c1"># compute Schmidt quasi-normalized associated Legendre functions</span>
    <span class="n">Pnm</span> <span class="o">=</span> <span class="n">legendre_poly</span><span class="p">(</span><span class="n">nmax</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>

    <span class="c1"># generate surface grid: [0., 360.] x [0., 180.]</span>
    <span class="n">theta_grid</span><span class="p">,</span> <span class="n">phi_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">)</span>

    <span class="c1"># predefine array</span>
    <span class="n">coeffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nmax</span><span class="o">*</span><span class="p">(</span><span class="n">nmax</span><span class="o">+</span><span class="mi">2</span><span class="p">),),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

    <span class="c1"># evaluate function at grid points</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">theta_grid</span><span class="p">,</span> <span class="n">phi_grid</span><span class="p">)</span>

    <span class="n">fft</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">n_phi</span>

    <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># index of row</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nmax</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>

        <span class="n">norm</span> <span class="o">=</span> <span class="mf">2.</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># inner product of Pnm&#39;s</span>

        <span class="c1"># m = 0</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">fft</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">Pnm</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">weights</span><span class="p">)</span> <span class="o">/</span> <span class="n">norm</span>
        <span class="n">coeffs</span><span class="p">[</span><span class="n">row</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">real</span>
        <span class="n">row</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># m &gt; 0</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>

            <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">fft</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">*</span><span class="n">Pnm</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span><span class="o">*</span><span class="n">weights</span><span class="p">)</span> <span class="o">/</span> <span class="n">norm</span>
            <span class="n">coeffs</span><span class="p">[</span><span class="n">row</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">real</span>
            <span class="n">coeffs</span><span class="p">[</span><span class="n">row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">c</span><span class="o">.</span><span class="n">imag</span>

            <span class="n">row</span> <span class="o">+=</span> <span class="mi">2</span>  <span class="c1"># update row index</span>

    <span class="k">return</span> <span class="n">coeffs</span></div>


<div class="viewcode-block" id="sun_position"><a class="viewcode-back" href="../../functions/chaosmagpy.coordinate_utils.sun_position.html#chaosmagpy.coordinate_utils.sun_position">[docs]</a><span class="k">def</span> <span class="nf">sun_position</span><span class="p">(</span><span class="n">time</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the sun&#39;s position in longitude and colatitude at a given time</span>
<span class="sd">    (mjd2000).</span>

<span class="sd">    It is accurate for years 1901 through 2099, to within 0.006 deg.</span>
<span class="sd">    Input shape is preserved.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    time : ndarray, shape (...)</span>
<span class="sd">        Time given as modified Julian date, i.e. with respect to the date 0h00</span>
<span class="sd">        January 1, 2000 (mjd2000).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    theta : ndarray, shape (...)</span>
<span class="sd">        Geographic colatitude of sun&#39;s position in degrees</span>
<span class="sd">        :math:`[0^\\circ, 180^\\circ]`.</span>
<span class="sd">    phi : ndarray, shape (...)</span>
<span class="sd">        Geographic east longitude of sun&#39;s position in degrees</span>
<span class="sd">        :math:`(-180^\\circ, 180^\\circ]`.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    Taken from `here &lt;http://jsoc.stanford.edu/doc/keywords/Chris_Russel/</span>
<span class="sd">    Geophysical%20Coordinate%20Transformations.htm#appendix2&gt;`_</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">180</span>
    <span class="n">year</span> <span class="o">=</span> <span class="mi">2000</span>  <span class="c1"># reference year for mjd2000</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">((</span><span class="n">year</span> <span class="o">+</span> <span class="n">time</span> <span class="o">//</span> <span class="mf">365.25</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2099</span><span class="p">)</span> \
        <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">((</span><span class="n">year</span> <span class="o">-</span> <span class="n">time</span> <span class="o">//</span> <span class="mf">365.25</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1901</span><span class="p">),</span> \
        <span class="p">(</span><span class="s2">&quot;Time must be between 1901 and 2099.&quot;</span><span class="p">)</span>

    <span class="n">frac_day</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">remainder</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># decimal fraction of a day</span>
    <span class="n">julian_date</span> <span class="o">=</span> <span class="mi">365</span> <span class="o">*</span> <span class="p">(</span><span class="n">year</span><span class="o">-</span><span class="mi">1900</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">year</span><span class="o">-</span><span class="mi">1901</span><span class="p">)</span><span class="o">//</span><span class="mi">4</span> <span class="o">+</span> <span class="n">time</span> <span class="o">+</span> <span class="mf">0.5</span>

    <span class="n">t</span> <span class="o">=</span> <span class="n">julian_date</span><span class="o">/</span><span class="mi">36525</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">remainder</span><span class="p">(</span><span class="mf">279.696678</span> <span class="o">+</span> <span class="mf">0.9856473354</span><span class="o">*</span><span class="n">julian_date</span><span class="p">,</span> <span class="mf">360.</span><span class="p">)</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">remainder</span><span class="p">(</span><span class="mf">358.475845</span> <span class="o">+</span> <span class="mf">0.985600267</span><span class="o">*</span><span class="n">julian_date</span><span class="p">,</span> <span class="mf">360.</span><span class="p">)</span>

    <span class="n">slong</span> <span class="o">=</span> <span class="n">v</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.91946</span> <span class="o">-</span> <span class="mf">0.004789</span><span class="o">*</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">g</span><span class="o">*</span><span class="n">rad</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.020094</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">g</span><span class="o">*</span><span class="n">rad</span><span class="p">)</span>
    <span class="n">obliq</span> <span class="o">=</span> <span class="p">(</span><span class="mf">23.45229</span> <span class="o">-</span> <span class="mf">0.0130125</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
    <span class="n">slp</span> <span class="o">=</span> <span class="p">(</span><span class="n">slong</span> <span class="o">-</span> <span class="mf">0.005686</span><span class="p">)</span>

    <span class="n">sind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">obliq</span><span class="o">*</span><span class="n">rad</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">slp</span><span class="o">*</span><span class="n">rad</span><span class="p">)</span>
    <span class="n">cosd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">sind</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1">#  sun&#39;s declination in radians</span>
    <span class="n">declination</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">sind</span><span class="o">/</span><span class="n">cosd</span><span class="p">)</span>

    <span class="c1"># sun&#39;s right right ascension in radians (0, 2*pi)</span>
    <span class="n">right_ascension</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">sind</span><span class="o">/</span><span class="p">(</span><span class="n">cosd</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">obliq</span><span class="o">*</span><span class="n">rad</span><span class="p">)),</span>
                                         <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">slp</span><span class="o">*</span><span class="n">rad</span><span class="p">)</span><span class="o">/</span><span class="n">cosd</span><span class="p">)</span>

    <span class="c1"># Greenwich mean siderial time in radians (0, 2*pi)</span>
    <span class="n">gmst</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">remainder</span><span class="p">(</span><span class="mf">279.690983</span> <span class="o">+</span> <span class="mf">0.9856473354</span><span class="o">*</span><span class="n">julian_date</span>
                        <span class="o">+</span> <span class="mf">360.</span><span class="o">*</span><span class="n">frac_day</span> <span class="o">+</span> <span class="mf">180.</span><span class="p">,</span> <span class="mf">360.</span><span class="p">)</span> <span class="o">*</span> <span class="n">rad</span>

    <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="n">declination</span><span class="p">)</span>  <span class="c1"># convert to colatitude</span>
    <span class="n">phi</span> <span class="o">=</span> <span class="n">center_azimuth</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">right_ascension</span> <span class="o">-</span> <span class="n">gmst</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span></div>


<div class="viewcode-block" id="zenith_angle"><a class="viewcode-back" href="../../functions/chaosmagpy.coordinate_utils.zenith_angle.html#chaosmagpy.coordinate_utils.zenith_angle">[docs]</a><span class="k">def</span> <span class="nf">zenith_angle</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the solar zenith angle.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    time : ndarray, shape (...)</span>
<span class="sd">        Time in modified Julian date.</span>
<span class="sd">    theta : ndarray, shape (...)</span>
<span class="sd">        Colatitude in degrees.</span>
<span class="sd">    phi : ndarray, shape (...)</span>
<span class="sd">        Longitude in degrees.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    zeta : ndarray, shape (...)</span>
<span class="sd">        Zenith angle in degrees :math:`[0^\\circ, 180^\\circ]` (angle between</span>
<span class="sd">        the local zenith and the center of the solar disc). Solar elevation</span>
<span class="sd">        angle is then computed by :math:`90^\\circ - \\theta_\\mathrm{zenith}`.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">theta_sun</span><span class="p">,</span> <span class="n">phi_sun</span> <span class="o">=</span> <span class="n">sun_position</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>

    <span class="n">colat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">theta_sun</span><span class="p">)</span>
    <span class="n">azim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">phi_sun</span><span class="p">)</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>

    <span class="n">cos_zeta</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">colat</span><span class="p">)</span> <span class="o">+</span>
                <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">colat</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">azim</span> <span class="o">-</span> <span class="n">phi</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">cos_zeta</span><span class="p">))</span></div>


<div class="viewcode-block" id="spherical_to_cartesian"><a class="viewcode-back" href="../../functions/chaosmagpy.coordinate_utils.spherical_to_cartesian.html#chaosmagpy.coordinate_utils.spherical_to_cartesian">[docs]</a><span class="k">def</span> <span class="nf">spherical_to_cartesian</span><span class="p">(</span><span class="n">radius</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert spherical to cartesian coordinates.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    radius : float or ndarray, shape (...)</span>
<span class="sd">        Radius.</span>
<span class="sd">    theta : float or ndarray, shape (...)</span>
<span class="sd">        Colatitude in degrees.</span>
<span class="sd">    phi : float or ndarray, shape (...)</span>
<span class="sd">        Longitude in degrees.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    x, y, z : float or ndarray, shape(...)</span>
<span class="sd">        Cartesian coordinates.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span></div>


<div class="viewcode-block" id="cartesian_to_spherical"><a class="viewcode-back" href="../../functions/chaosmagpy.coordinate_utils.cartesian_to_spherical.html#chaosmagpy.coordinate_utils.cartesian_to_spherical">[docs]</a><span class="k">def</span> <span class="nf">cartesian_to_spherical</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert geocentric cartesian to spherical coordinates.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x, y, z : float or ndarray, shape (...)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    radius : float or ndarray, shape (...)</span>
<span class="sd">        Radius.</span>
<span class="sd">    theta : float or ndarray, shape (...)</span>
<span class="sd">        Colatitude in degrees :math:`[0^\\circ, 180^\\circ]`.</span>
<span class="sd">    phi : float or ndarray, shape (...)</span>
<span class="sd">        Longitude in degrees :math:`(-180^\\circ,180^\\circ]`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">radius</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">z</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="n">z</span><span class="p">)</span>
    <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">radius</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span></div>


<div class="viewcode-block" id="gg_to_geo"><a class="viewcode-back" href="../../functions/chaosmagpy.coordinate_utils.gg_to_geo.html#chaosmagpy.coordinate_utils.gg_to_geo">[docs]</a><span class="k">def</span> <span class="nf">gg_to_geo</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">beta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute geocentric colatitude and radius from geodetic colatitude and</span>
<span class="sd">    vertical height above the ellipsoid as defined by the World Geodetic System</span>
<span class="sd">    1984 (WGS84).</span>

<span class="sd">    The equatorial and polar radius of the ellipsoid that approximates Earth&#39;s</span>
<span class="sd">    surface are stored in ``chaosmagpy.basicConfig[&#39;params.ellipsoid&#39;]``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    height : ndarray, shape (...)</span>
<span class="sd">        Altitude in kilometers.</span>
<span class="sd">    beta : ndarray, shape (...)</span>
<span class="sd">        Geodetic colatitude</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    radius : ndarray, shape (...)</span>
<span class="sd">        Geocentric radius in kilometers.</span>
<span class="sd">    theta : ndarray, shape (...)</span>
<span class="sd">        Geocentric colatitude in degrees.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    Equations (51)-(53) from &quot;The main field&quot; (chapter 4) by Langel, R. A. in:</span>

<span class="sd">    &quot;Geomagnetism&quot;, Volume 1, Jacobs, J. A., Academic Press, 1987.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">a</span> <span class="o">=</span> <span class="n">basicConfig</span><span class="p">[</span><span class="s1">&#39;params.ellipsoid&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># equatorial radius</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">basicConfig</span><span class="p">[</span><span class="s1">&#39;params.ellipsoid&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># polar radius</span>

    <span class="c1"># convert geodetic colatitude to latitude</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mf">90.</span> <span class="o">-</span> <span class="n">beta</span><span class="p">)</span>

    <span class="n">sin_alpha_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">cos_alpha_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>

    <span class="n">factor</span> <span class="o">=</span> <span class="n">height</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">a</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">cos_alpha_2</span> <span class="o">+</span> <span class="n">b</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">sin_alpha_2</span><span class="p">)</span>
    <span class="n">gamma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">((</span><span class="n">factor</span> <span class="o">+</span> <span class="n">b</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">alpha</span><span class="p">),</span> <span class="p">(</span><span class="n">factor</span> <span class="o">+</span> <span class="n">a</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>

    <span class="n">theta</span> <span class="o">=</span> <span class="mf">90.</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span>
    <span class="n">radius</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">height</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">factor</span> <span class="o">+</span>
                     <span class="n">a</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="p">(</span><span class="n">b</span><span class="o">/</span><span class="n">a</span><span class="p">)</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span><span class="o">*</span><span class="n">sin_alpha_2</span><span class="p">)</span> <span class="o">/</span>
                          <span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="p">(</span><span class="n">b</span><span class="o">/</span><span class="n">a</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">sin_alpha_2</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">radius</span><span class="p">,</span> <span class="n">theta</span></div>


<div class="viewcode-block" id="geo_to_gg"><a class="viewcode-back" href="../../functions/chaosmagpy.coordinate_utils.geo_to_gg.html#chaosmagpy.coordinate_utils.geo_to_gg">[docs]</a><span class="k">def</span> <span class="nf">geo_to_gg</span><span class="p">(</span><span class="n">radius</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute geodetic colatitude and vertical height above the ellipsoid as</span>
<span class="sd">    defined by the World Geodetic System 1984 (WGS84) from geocentric radius</span>
<span class="sd">    and colatitude.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    radius : ndarray, shape (...)</span>
<span class="sd">        Geocentric radius in kilometers.</span>
<span class="sd">    theta : ndarray, shape (...)</span>
<span class="sd">        Geocentric colatitude in degrees.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    height : ndarray, shape (...)</span>
<span class="sd">        Altitude in kilometers.</span>
<span class="sd">    beta : ndarray, shape (...)</span>
<span class="sd">        Geodetic colatitude in degrees.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Round-off errors might lead to a failure of the algorithm especially but</span>
<span class="sd">    not exclusively for points close to the geographic poles. Corresponding</span>
<span class="sd">    geodetic coordinates are returned as NaN.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    Function uses Heikkinen&#39;s algorithm taken from:</span>

<span class="sd">    Zhu, J., &quot;Conversion of Earth-centered Earth-fixed coordinates to geodetic</span>
<span class="sd">    coordinates&quot;, IEEE Transactions on Aerospace and Electronic Systems, 1994,</span>
<span class="sd">    vol. 30, num. 3, pp. 957-961</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">a</span> <span class="o">=</span> <span class="n">basicConfig</span><span class="p">[</span><span class="s1">&#39;params.ellipsoid&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># equatorial radius</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">basicConfig</span><span class="p">[</span><span class="s1">&#39;params.ellipsoid&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># polar radius</span>

    <span class="n">a2</span> <span class="o">=</span> <span class="n">a</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">b2</span> <span class="o">=</span> <span class="n">b</span><span class="o">**</span><span class="mi">2</span>

    <span class="n">e2</span> <span class="o">=</span> <span class="p">(</span><span class="n">a2</span> <span class="o">-</span> <span class="n">b2</span><span class="p">)</span> <span class="o">/</span> <span class="n">a2</span>  <span class="c1"># squared eccentricity</span>
    <span class="n">e4</span> <span class="o">=</span> <span class="n">e2</span><span class="o">*</span><span class="n">e2</span>
    <span class="n">ep2</span> <span class="o">=</span> <span class="p">(</span><span class="n">a2</span> <span class="o">-</span> <span class="n">b2</span><span class="p">)</span> <span class="o">/</span> <span class="n">b2</span>  <span class="c1"># squared primed eccentricity</span>

    <span class="n">r</span> <span class="o">=</span> <span class="n">radius</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">radius</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span>

    <span class="n">r2</span> <span class="o">=</span> <span class="n">r</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">z2</span> <span class="o">=</span> <span class="n">z</span><span class="o">**</span><span class="mi">2</span>

    <span class="n">F</span> <span class="o">=</span> <span class="mi">54</span><span class="o">*</span><span class="n">b2</span><span class="o">*</span><span class="n">z2</span>

    <span class="n">G</span> <span class="o">=</span> <span class="n">r2</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">e2</span><span class="p">)</span><span class="o">*</span><span class="n">z2</span> <span class="o">-</span> <span class="n">e2</span><span class="o">*</span><span class="p">(</span><span class="n">a2</span> <span class="o">-</span> <span class="n">b2</span><span class="p">)</span>

    <span class="n">c</span> <span class="o">=</span> <span class="n">e4</span><span class="o">*</span><span class="n">F</span><span class="o">*</span><span class="n">r2</span> <span class="o">/</span> <span class="n">G</span><span class="o">**</span><span class="mi">3</span>

    <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">+</span> <span class="n">c</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">c</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">c</span><span class="p">))</span><span class="o">**</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span>

    <span class="n">P</span> <span class="o">=</span> <span class="n">F</span> <span class="o">/</span> <span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="n">s</span> <span class="o">+</span> <span class="mf">1.</span><span class="o">/</span><span class="n">s</span> <span class="o">+</span> <span class="mf">1.</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">G</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="n">Q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">e4</span><span class="o">*</span><span class="n">P</span><span class="p">)</span>

    <span class="n">r0</span> <span class="o">=</span> <span class="o">-</span><span class="n">P</span><span class="o">*</span><span class="n">e2</span><span class="o">*</span><span class="n">r</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">+</span> <span class="n">Q</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
        <span class="mf">0.5</span><span class="o">*</span><span class="n">a2</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span> <span class="o">+</span> <span class="mf">1.</span><span class="o">/</span><span class="n">Q</span><span class="p">)</span> <span class="o">-</span> <span class="n">P</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">e2</span><span class="p">)</span><span class="o">*</span><span class="n">z2</span> <span class="o">/</span> <span class="p">(</span><span class="n">Q</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span> <span class="o">+</span> <span class="n">Q</span><span class="p">))</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">P</span><span class="o">*</span><span class="n">r2</span><span class="p">)</span>

    <span class="n">U</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">r</span> <span class="o">-</span> <span class="n">e2</span><span class="o">*</span><span class="n">r0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">z2</span><span class="p">)</span>

    <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">r</span> <span class="o">-</span> <span class="n">e2</span><span class="o">*</span><span class="n">r0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">e2</span><span class="p">)</span><span class="o">*</span><span class="n">z2</span><span class="p">)</span>

    <span class="n">z0</span> <span class="o">=</span> <span class="n">b2</span><span class="o">*</span><span class="n">z</span><span class="o">/</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">V</span><span class="p">)</span>

    <span class="n">height</span> <span class="o">=</span> <span class="n">U</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">b2</span> <span class="o">/</span> <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">V</span><span class="p">))</span>

    <span class="n">beta</span> <span class="o">=</span> <span class="mf">90.</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">z</span> <span class="o">+</span> <span class="n">ep2</span><span class="o">*</span><span class="n">z0</span><span class="p">,</span> <span class="n">r</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">height</span><span class="p">,</span> <span class="n">beta</span></div>


<div class="viewcode-block" id="basevectors_gsm"><a class="viewcode-back" href="../../functions/chaosmagpy.coordinate_utils.basevectors_gsm.html#chaosmagpy.coordinate_utils.basevectors_gsm">[docs]</a><span class="k">def</span> <span class="nf">basevectors_gsm</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">dipole</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the unit base vectors of the GSM coordinate system with respect to</span>
<span class="sd">    the standard geographic coordinate system (GEO).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    time : float or ndarray, shape (...)</span>
<span class="sd">        Time given as modified Julian date, i.e. with respect to the date 0h00</span>
<span class="sd">        January 1, 2000 (mjd2000).</span>
<span class="sd">    dipole : ndarray, shape (3,), optional</span>
<span class="sd">        Dipole spherical harmonics :math:`g_1^0`, :math:`g_1^1` and</span>
<span class="sd">        :math:`h_1^1`. Defaults to ``basicConfig[&#39;params.dipole&#39;]``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    gsm_1, gsm_2, gsm_3 : ndarray, shape (..., 3)</span>
<span class="sd">        GSM unit base vectors. The leading dimension agrees with the shape of</span>
<span class="sd">        ``time``, while the last dimension contains the unit vector</span>
<span class="sd">        components in terms of GEO.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">dipole</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dipole</span> <span class="o">=</span> <span class="n">basicConfig</span><span class="p">[</span><span class="s1">&#39;params.dipole&#39;</span><span class="p">]</span>

    <span class="n">vec</span> <span class="o">=</span> <span class="n">_dipole_to_unit</span><span class="p">(</span><span class="n">dipole</span><span class="p">)</span>

    <span class="c1"># get sun&#39;s position at specified times</span>
    <span class="n">theta_sun</span><span class="p">,</span> <span class="n">phi_sun</span> <span class="o">=</span> <span class="n">sun_position</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>

    <span class="c1"># compute sun&#39;s position</span>
    <span class="n">x_sun</span><span class="p">,</span> <span class="n">y_sun</span><span class="p">,</span> <span class="n">z_sun</span> <span class="o">=</span> <span class="n">spherical_to_cartesian</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">theta_sun</span><span class="p">,</span> <span class="n">phi_sun</span><span class="p">)</span>

    <span class="c1"># create array in which the first unit vector resides in last dimension</span>
    <span class="n">gsm_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">x_sun</span><span class="o">.</span><span class="n">shape</span> <span class="o">+</span> <span class="p">(</span><span class="mi">3</span><span class="p">,))</span>
    <span class="n">gsm_1</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x_sun</span>
    <span class="n">gsm_1</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_sun</span>
    <span class="n">gsm_1</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">z_sun</span>

    <span class="c1"># compute second base vector of GSM using the cross product of the</span>
    <span class="c1"># dipole unit vector with the first unit base vector</span>

    <span class="n">gsm_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">gsm_1</span><span class="p">)</span>  <span class="c1"># over last dimension by default</span>
    <span class="n">norm_gsm_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">gsm_2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">gsm_2</span> <span class="o">=</span> <span class="n">gsm_2</span> <span class="o">/</span> <span class="n">norm_gsm_2</span>

    <span class="c1"># compute third unit base vector using the cross product of first and</span>
    <span class="c1"># second unit base vector</span>
    <span class="n">gsm_3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">gsm_1</span><span class="p">,</span> <span class="n">gsm_2</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">gsm_1</span><span class="p">,</span> <span class="n">gsm_2</span><span class="p">,</span> <span class="n">gsm_3</span></div>


<div class="viewcode-block" id="basevectors_sm"><a class="viewcode-back" href="../../functions/chaosmagpy.coordinate_utils.basevectors_sm.html#chaosmagpy.coordinate_utils.basevectors_sm">[docs]</a><span class="k">def</span> <span class="nf">basevectors_sm</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">dipole</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the unit base vectors of the SM coordinate system with respect to</span>
<span class="sd">    the standard geographic coordinate system (GEO).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    time : float or ndarray, shape (...)</span>
<span class="sd">        Time given as modified Julian date, i.e. with respect to the date 0h00</span>
<span class="sd">        January 1, 2000 (mjd2000).</span>
<span class="sd">    dipole : ndarray, shape (3,), optional</span>
<span class="sd">        Dipole spherical harmonics :math:`g_1^0`, :math:`g_1^1` and</span>
<span class="sd">        :math:`h_1^1`. Defaults to ``basicConfig[&#39;params.dipole&#39;]``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sm_1, sm_2, sm_3 : ndarray, shape (..., 3)</span>
<span class="sd">        SM unit base vectors. The leading dimension agrees with the shape of</span>
<span class="sd">        ``time``, while the last dimension contains the unit vector</span>
<span class="sd">        components in terms of GEO.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">dipole</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dipole</span> <span class="o">=</span> <span class="n">basicConfig</span><span class="p">[</span><span class="s1">&#39;params.dipole&#39;</span><span class="p">]</span>

    <span class="n">vec</span> <span class="o">=</span> <span class="n">_dipole_to_unit</span><span class="p">(</span><span class="n">dipole</span><span class="p">)</span>

    <span class="c1"># get sun&#39;s position at specified times and convert to cartesian</span>
    <span class="n">theta_sun</span><span class="p">,</span> <span class="n">phi_sun</span> <span class="o">=</span> <span class="n">sun_position</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
    <span class="n">x_sun</span><span class="p">,</span> <span class="n">y_sun</span><span class="p">,</span> <span class="n">z_sun</span> <span class="o">=</span> <span class="n">spherical_to_cartesian</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">theta_sun</span><span class="p">,</span> <span class="n">phi_sun</span><span class="p">)</span>

    <span class="c1"># create array in which the sun&#39;s vector resides in last dimension</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">x_sun</span><span class="o">.</span><span class="n">shape</span> <span class="o">+</span> <span class="p">(</span><span class="mi">3</span><span class="p">,))</span>
    <span class="n">s</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x_sun</span>
    <span class="n">s</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_sun</span>
    <span class="n">s</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">z_sun</span>

    <span class="c1"># set third unit base vector of SM to dipole unit vector</span>
    <span class="n">sm_3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">x_sun</span><span class="o">.</span><span class="n">shape</span> <span class="o">+</span> <span class="p">(</span><span class="mi">3</span><span class="p">,))</span>
    <span class="n">sm_3</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">sm_3</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">vec</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">sm_3</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">vec</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

    <span class="c1"># compute second base vector of SM using the cross product of the IGRF</span>
    <span class="c1"># dipole unit vector and the sun direction vector</span>
    <span class="n">sm_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">sm_3</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
    <span class="n">norm_sm_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">sm_2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">sm_2</span> <span class="o">=</span> <span class="n">sm_2</span> <span class="o">/</span> <span class="n">norm_sm_2</span>

    <span class="c1"># compute third unit base vector using the cross product of second and</span>
    <span class="c1"># third unit base vector</span>
    <span class="n">sm_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">sm_2</span><span class="p">,</span> <span class="n">sm_3</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">sm_1</span><span class="p">,</span> <span class="n">sm_2</span><span class="p">,</span> <span class="n">sm_3</span></div>


<div class="viewcode-block" id="basevectors_mag"><a class="viewcode-back" href="../../functions/chaosmagpy.coordinate_utils.basevectors_mag.html#chaosmagpy.coordinate_utils.basevectors_mag">[docs]</a><span class="k">def</span> <span class="nf">basevectors_mag</span><span class="p">(</span><span class="n">dipole</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the unit base vectors of the central-dipole coordinate system</span>
<span class="sd">    (sometimes referred to as MAG) with respect to the standard geographic</span>
<span class="sd">    coordinate system (GEO).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dipole : ndarray, shape (3,), optional</span>
<span class="sd">        Dipole spherical harmonics :math:`g_1^0`, :math:`g_1^1` and</span>
<span class="sd">        :math:`h_1^1`. Defaults to ``basicConfig[&#39;params.dipole&#39;]``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    mag_1, mag_2, mag_3 : ndarray, shape (3,)</span>
<span class="sd">        MAG unit base vectors resolved into components in GEO.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">dipole</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dipole</span> <span class="o">=</span> <span class="n">basicConfig</span><span class="p">[</span><span class="s1">&#39;params.dipole&#39;</span><span class="p">]</span>

    <span class="n">mag_3</span> <span class="o">=</span> <span class="n">_dipole_to_unit</span><span class="p">(</span><span class="n">dipole</span><span class="p">)</span>

    <span class="n">mag_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">]),</span> <span class="n">mag_3</span><span class="p">)</span>
    <span class="n">mag_2</span> <span class="o">=</span> <span class="n">mag_2</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">mag_2</span><span class="p">)</span>

    <span class="n">mag_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">mag_2</span><span class="p">,</span> <span class="n">mag_3</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">mag_1</span><span class="p">,</span> <span class="n">mag_2</span><span class="p">,</span> <span class="n">mag_3</span></div>


<div class="viewcode-block" id="basevectors_use"><a class="viewcode-back" href="../../functions/chaosmagpy.coordinate_utils.basevectors_use.html#chaosmagpy.coordinate_utils.basevectors_use">[docs]</a><span class="k">def</span> <span class="nf">basevectors_use</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the unit base vectors of local orthogonal coordinate system USE</span>
<span class="sd">    (Up-South-East) on the spherical surface (theta, phi) with respect to the</span>
<span class="sd">    standard geographic coordinate system (GEO).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    theta : ndarray, shape (...)</span>
<span class="sd">        Geocentric colatitude in degrees :math:`(0^\\circ, 180^\\circ)`, i.e.</span>
<span class="sd">        exclude poles.</span>
<span class="sd">    phi : ndarray, shape (...)</span>
<span class="sd">        Geocentric longitude in degrees.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    use_1, use_2, use_3 : ndarray, shape (..., 3)</span>
<span class="sd">        USE unit base vectors. The leading dimension agrees with the shape of</span>
<span class="sd">        ``theta`` or ``phi``, while the last dimension contains the unit</span>
<span class="sd">        vector components in terms of GEO.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span>
    <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">phi</span><span class="p">))</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Basevectors are not defined at poles.&quot;</span><span class="p">)</span>

    <span class="n">grid_shape</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">theta</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">phi</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="c1"># predefine output, the components of the base vectors in the last</span>
    <span class="c1"># dimensions: shape (..., 3, 3)</span>
    <span class="n">use_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">grid_shape</span> <span class="o">+</span> <span class="p">(</span><span class="mi">3</span><span class="p">,))</span>
    <span class="n">use_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">grid_shape</span> <span class="o">+</span> <span class="p">(</span><span class="mi">3</span><span class="p">,))</span>
    <span class="n">use_3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">grid_shape</span> <span class="o">+</span> <span class="p">(</span><span class="mi">3</span><span class="p">,))</span>

    <span class="c1"># calculate and save sin/cos of angles</span>
    <span class="n">sin_phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
    <span class="n">sin_theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">cos_phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
    <span class="n">cos_theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

    <span class="c1"># first base vector (Up)</span>
    <span class="n">use_1</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">sin_theta</span><span class="o">*</span><span class="n">cos_phi</span>
    <span class="n">use_1</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sin_theta</span><span class="o">*</span><span class="n">sin_phi</span>
    <span class="n">use_1</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">cos_theta</span>

    <span class="c1"># second base vector (South)</span>
    <span class="n">use_2</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cos_theta</span><span class="o">*</span><span class="n">cos_phi</span>
    <span class="n">use_2</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cos_theta</span><span class="o">*</span><span class="n">sin_phi</span>
    <span class="n">use_2</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">sin_theta</span>

    <span class="c1"># third base vector (East)</span>
    <span class="n">use_3</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">sin_phi</span>
    <span class="n">use_3</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cos_phi</span>
    <span class="n">use_3</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">return</span> <span class="n">use_1</span><span class="p">,</span> <span class="n">use_2</span><span class="p">,</span> <span class="n">use_3</span></div>


<div class="viewcode-block" id="geo_to_base"><a class="viewcode-back" href="../../functions/chaosmagpy.coordinate_utils.geo_to_base.html#chaosmagpy.coordinate_utils.geo_to_base">[docs]</a><span class="k">def</span> <span class="nf">geo_to_base</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">base_1</span><span class="p">,</span> <span class="n">base_2</span><span class="p">,</span> <span class="n">base_3</span><span class="p">,</span> <span class="n">inverse</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transform spherical geographic coordinates into spherical coordinates of a</span>
<span class="sd">    rotated geocentric coordinate system as given by three base vectors.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    theta : float or ndarray, shape (...)</span>
<span class="sd">        Geographic colatitude in degrees.</span>
<span class="sd">    phi : float or ndarray, shape (...)</span>
<span class="sd">        Geographic longitude in degrees.</span>
<span class="sd">    base_1, base_2, base_3 : ndarray, shape (3,) or (..., 3)</span>
<span class="sd">        Base vector 1 through 3 resolved into components with respect to GEO.</span>
<span class="sd">    inverse : bool, optional</span>
<span class="sd">        Use inverse transformation instead, i.e. transform from rotated to</span>
<span class="sd">        geographic (default is False).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    theta : ndarray, shape (...)</span>
<span class="sd">        Colatitude in degrees :math:`[0^\\circ, 180^\\circ]` of the rotated</span>
<span class="sd">        coordinate system.</span>
<span class="sd">    phi : ndarray, shape (...)</span>
<span class="sd">        Longitude in degrees :math:`(-180^\\circ, 180^\\circ]` of the rotated</span>
<span class="sd">        coordinate system.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    transform_points</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">inverse</span> <span class="o">=</span> <span class="kc">False</span> <span class="k">if</span> <span class="n">inverse</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">inverse</span>

    <span class="c1"># convert spherical to cartesian (radius = 1) coordinates</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">spherical_to_cartesian</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">inverse</span><span class="p">:</span>
        <span class="c1"># components of unit base vectors are the columns of inverse matrix</span>
        <span class="n">x_ref</span> <span class="o">=</span> <span class="n">base_1</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">base_2</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">base_3</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">z</span>
        <span class="n">y_ref</span> <span class="o">=</span> <span class="n">base_1</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">base_2</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">base_3</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">z</span>
        <span class="n">z_ref</span> <span class="o">=</span> <span class="n">base_1</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">base_2</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">base_3</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">z</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># components of unit base vectors are the rows of the rotation matrix</span>
        <span class="n">x_ref</span> <span class="o">=</span> <span class="n">base_1</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">base_1</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">base_1</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">z</span>
        <span class="n">y_ref</span> <span class="o">=</span> <span class="n">base_2</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">base_2</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">base_2</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">z</span>
        <span class="n">z_ref</span> <span class="o">=</span> <span class="n">base_3</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">base_3</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">base_3</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">z</span>

    <span class="c1"># convert to spherical coordinates, discard radius as it is 1.</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">theta_ref</span><span class="p">,</span> <span class="n">phi_ref</span> <span class="o">=</span> <span class="n">cartesian_to_spherical</span><span class="p">(</span><span class="n">x_ref</span><span class="p">,</span> <span class="n">y_ref</span><span class="p">,</span> <span class="n">z_ref</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">theta_ref</span><span class="p">,</span> <span class="n">phi_ref</span></div>


<div class="viewcode-block" id="transform_points"><a class="viewcode-back" href="../../functions/chaosmagpy.coordinate_utils.transform_points.html#chaosmagpy.coordinate_utils.transform_points">[docs]</a><span class="k">def</span> <span class="nf">transform_points</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">reference</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inverse</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">dipole</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transform spherical geographic coordinates (GEO) into spherical coordinates</span>
<span class="sd">    of a rotated geocentric coordinate system.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    theta : float or ndarray, shape (...)</span>
<span class="sd">        Geographic colatitude in degrees (GEO).</span>
<span class="sd">    phi : float or ndarray, shape (...)</span>
<span class="sd">        Geographic longitude in degrees (GEO).</span>
<span class="sd">    time : float or ndarray, shape (...)</span>
<span class="sd">        Time given as modified Julian date, i.e. with respect to the date 0h00</span>
<span class="sd">        January 1, 2000 (mjd2000). Ignored for ``reference=&#39;mag&#39;``.</span>
<span class="sd">    reference : {&#39;gsm&#39;, &#39;sm&#39;, &#39;mag&#39;}</span>
<span class="sd">        Target coordinate system.</span>
<span class="sd">    inverse : bool</span>
<span class="sd">        Use inverse transformation instead, i.e. transform from the rotated</span>
<span class="sd">        geocentric coordinates to GEO (default is False).</span>
<span class="sd">    dipole : ndarray, shape (3,), optional</span>
<span class="sd">        Dipole spherical harmonics :math:`g_1^0`, :math:`g_1^1` and</span>
<span class="sd">        :math:`h_1^1`. Defaults to ``basicConfig[&#39;params.dipole&#39;]``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    theta : ndarray, shape (...)</span>
<span class="sd">        Colatitude in degrees :math:`[0^\\circ, 180^\\circ]` of the rotated</span>
<span class="sd">        geocentric coordinate system.</span>
<span class="sd">    phi : ndarray, shape (...)</span>
<span class="sd">        Longitude in degrees :math:`(-180^\\circ, 180^\\circ]` of the rotated</span>
<span class="sd">        geocentric coordinate system.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    geo_to_base</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">reference</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">reference</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="n">inverse</span> <span class="o">=</span> <span class="kc">False</span> <span class="k">if</span> <span class="n">inverse</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">inverse</span>

    <span class="k">if</span> <span class="n">dipole</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dipole</span> <span class="o">=</span> <span class="n">basicConfig</span><span class="p">[</span><span class="s1">&#39;params.dipole&#39;</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">reference</span> <span class="o">==</span> <span class="s1">&#39;gsm&#39;</span><span class="p">:</span>
        <span class="c1"># compute GSM base vectors</span>
        <span class="n">base_1</span><span class="p">,</span> <span class="n">base_2</span><span class="p">,</span> <span class="n">base_3</span> <span class="o">=</span> <span class="n">basevectors_gsm</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">dipole</span><span class="o">=</span><span class="n">dipole</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">reference</span> <span class="o">==</span> <span class="s1">&#39;sm&#39;</span><span class="p">:</span>
        <span class="c1"># compute SM base vectors</span>
        <span class="n">base_1</span><span class="p">,</span> <span class="n">base_2</span><span class="p">,</span> <span class="n">base_3</span> <span class="o">=</span> <span class="n">basevectors_sm</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">dipole</span><span class="o">=</span><span class="n">dipole</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">reference</span> <span class="o">==</span> <span class="s1">&#39;mag&#39;</span><span class="p">:</span>
        <span class="c1"># compute centered dipole base vectors</span>
        <span class="n">base_1</span><span class="p">,</span> <span class="n">base_2</span><span class="p">,</span> <span class="n">base_3</span> <span class="o">=</span> <span class="n">basevectors_mag</span><span class="p">()</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unknown target reference system. Use one of &#39;</span>
                         <span class="s1">&#39;{&quot;gsm&quot;, &quot;sm&quot;, &quot;mag&quot;}.&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">inverse</span><span class="p">:</span>
        <span class="n">theta_base</span><span class="p">,</span> <span class="n">phi_base</span> <span class="o">=</span> <span class="n">geo_to_base</span><span class="p">(</span>
            <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">base_1</span><span class="p">,</span> <span class="n">base_2</span><span class="p">,</span> <span class="n">base_3</span><span class="p">,</span> <span class="n">inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">theta_base</span><span class="p">,</span> <span class="n">phi_base</span> <span class="o">=</span> <span class="n">geo_to_base</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">base_1</span><span class="p">,</span> <span class="n">base_2</span><span class="p">,</span> <span class="n">base_3</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">theta_base</span><span class="p">,</span> <span class="n">phi_base</span></div>


<div class="viewcode-block" id="matrix_geo_to_base"><a class="viewcode-back" href="../../functions/chaosmagpy.coordinate_utils.matrix_geo_to_base.html#chaosmagpy.coordinate_utils.matrix_geo_to_base">[docs]</a><span class="k">def</span> <span class="nf">matrix_geo_to_base</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">base_1</span><span class="p">,</span> <span class="n">base_2</span><span class="p">,</span> <span class="n">base_3</span><span class="p">,</span> <span class="n">inverse</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute matrices to trasnform vector components from USE frame at given</span>
<span class="sd">    spherical geographic coordinates into components with respect to a</span>
<span class="sd">    rotated geocentric coordinate system.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    theta : float or ndarray, shape (...)</span>
<span class="sd">        Geographic colatitude in degrees (GEO).</span>
<span class="sd">    phi : float or ndarray, shape (...)</span>
<span class="sd">        Geographic longitude in degrees (GEO).</span>
<span class="sd">    base_1, base_2, base_3 : ndarray, shape (..., 3)</span>
<span class="sd">        Base vectors 1 through 3 as columns with respect to GEO.</span>
<span class="sd">    inverse : bool</span>
<span class="sd">        Use inverse transformation instead, i.e. transform from rotated</span>
<span class="sd">        coordinates to geographic (default is False).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    theta : ndarray, shape (...)</span>
<span class="sd">        Reference colatitude in degrees :math:`[0^\\circ, 180^\\circ]`.</span>
<span class="sd">    phi : ndarray, shape (...)</span>
<span class="sd">        Reference longitude in degrees :math:`(-180^\\circ, 180^\\circ]`.</span>
<span class="sd">    R : ndarray, shape (..., 3, 3), optional</span>
<span class="sd">        Array of matrices that rotates vectors B in spherical GEO to the target</span>
<span class="sd">        spherical reference. The matrices (3x3) reside in the last two</span>
<span class="sd">        dimensions, while the leading dimensions are identical to the input</span>
<span class="sd">        grid.</span>

<span class="sd">        | B_radius_ref = B_radius</span>
<span class="sd">        | B_theta_ref  = R[1, 1]*B_theta + R[1, 2]*B_phi</span>
<span class="sd">        | B_phi_ref    = R[2, 1]*B_theta + R[2, 2]*B_phi</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    transform_vectors</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">inverse</span> <span class="o">=</span> <span class="kc">False</span> <span class="k">if</span> <span class="n">inverse</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">inverse</span>

    <span class="k">if</span> <span class="n">inverse</span><span class="p">:</span>
        <span class="n">theta_ref</span><span class="p">,</span> <span class="n">phi_ref</span> <span class="o">=</span> <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span>
        <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span> <span class="o">=</span> <span class="n">geo_to_base</span><span class="p">(</span><span class="n">theta_ref</span><span class="p">,</span> <span class="n">phi_ref</span><span class="p">,</span> <span class="n">base_1</span><span class="p">,</span> <span class="n">base_2</span><span class="p">,</span>
                                 <span class="n">base_3</span><span class="p">,</span> <span class="n">inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">theta_ref</span><span class="p">,</span> <span class="n">phi_ref</span> <span class="o">=</span> <span class="n">geo_to_base</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">base_1</span><span class="p">,</span> <span class="n">base_2</span><span class="p">,</span> <span class="n">base_3</span><span class="p">)</span>

    <span class="c1"># matrix to rotate vector from USE at (theta, phi) to GEO</span>
    <span class="n">R_use_to_geo</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">basevectors_use</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># rotate vector according to reference system defined by base vectors</span>
    <span class="n">R_geo_to_ref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">base_1</span><span class="p">,</span> <span class="n">base_2</span><span class="p">,</span> <span class="n">base_3</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># matrix to rotate vector from original USE to reference system</span>
    <span class="n">R_use_to_ref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">R_geo_to_ref</span><span class="p">,</span> <span class="n">R_use_to_geo</span><span class="p">)</span>

    <span class="c1"># matrix to rotate reference to new USE using the transpose</span>
    <span class="n">R_ref_to_use</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">basevectors_use</span><span class="p">(</span><span class="n">theta_ref</span><span class="p">,</span> <span class="n">phi_ref</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># complete rotation matrix: spherical GEO to spherical reference</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">R_ref_to_use</span><span class="p">,</span> <span class="n">R_use_to_ref</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">inverse</span><span class="p">:</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># transpose matrices</span>
        <span class="n">theta_ref</span><span class="p">,</span> <span class="n">phi_ref</span> <span class="o">=</span> <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span>  <span class="c1"># overwrite for correct output</span>

    <span class="k">return</span> <span class="n">theta_ref</span><span class="p">,</span> <span class="n">phi_ref</span><span class="p">,</span> <span class="n">R</span></div>


<div class="viewcode-block" id="transform_vectors"><a class="viewcode-back" href="../../functions/chaosmagpy.coordinate_utils.transform_vectors.html#chaosmagpy.coordinate_utils.transform_vectors">[docs]</a><span class="k">def</span> <span class="nf">transform_vectors</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">B_theta</span><span class="p">,</span> <span class="n">B_phi</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reference</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">inverse</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dipole</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transform vectors resolved into components in USE (Up-South-East) at given</span>
<span class="sd">    spherical geographic coordinates (GEO) to components in USE into components</span>
<span class="sd">    with respect to a rotated geocentric coordinate system.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    theta : float or ndarray, shape (...)</span>
<span class="sd">        Geographic colatitude in degrees (GEO).</span>
<span class="sd">    phi : float or ndarray, shape (...)</span>
<span class="sd">        Geographic longitude in degrees (GEO).</span>
<span class="sd">    B_theta : float or ndarray, shape (...)</span>
<span class="sd">        Colatitude vector components (GEO).</span>
<span class="sd">    B_phi : float or ndarray, shape (...)</span>
<span class="sd">        Azimuthal vector components (GEO).</span>
<span class="sd">    time : float or ndarray, shape (...)</span>
<span class="sd">        Time given as modified Julian date, i.e. with respect to the date 0h00</span>
<span class="sd">        January 1, 2000 (mjd2000). Ignored for ``reference=&#39;mag&#39;``.</span>
<span class="sd">    reference : {&#39;gsm&#39;, &#39;sm&#39;, &#39;mag&#39;}</span>
<span class="sd">        Target coordinate system.</span>
<span class="sd">    inverse : bool</span>
<span class="sd">        Use inverse transformation instead, i.e. transform from rotated</span>
<span class="sd">        coordinates to geographic (default is False).</span>
<span class="sd">    dipole : ndarray, shape (3,), optional</span>
<span class="sd">        Dipole spherical harmonics :math:`g_1^0`, :math:`g_1^1` and</span>
<span class="sd">        :math:`h_1^1`. Defaults to ``basicConfig[&#39;params.dipole&#39;]``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    theta : ndarray, shape (...)</span>
<span class="sd">        Colatitude in degrees :math:`[0^\\circ, 180^\\circ]` of the rotated</span>
<span class="sd">        geocentric coordinate system.</span>
<span class="sd">    phi : ndarray, shape (...)</span>
<span class="sd">        Longitude in degrees :math:`(-180^\\circ, 180^\\circ]` of the rotated</span>
<span class="sd">        geocentric coordinate system.</span>
<span class="sd">    B_theta : float or ndarray, shape (...)</span>
<span class="sd">        Colatitude vector components with respect to the rotated geocentric</span>
<span class="sd">        coordinate system.</span>
<span class="sd">    B_phi : float or ndarray, shape (...)</span>
<span class="sd">        Azimuthal vector components with respect to the rotated geocentric</span>
<span class="sd">        coordinate system.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    matrix_geo_to_base</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">inverse</span> <span class="o">=</span> <span class="kc">False</span> <span class="k">if</span> <span class="n">inverse</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">inverse</span>

    <span class="n">reference</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">reference</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">dipole</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dipole</span> <span class="o">=</span> <span class="n">basicConfig</span><span class="p">[</span><span class="s1">&#39;params.dipole&#39;</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">reference</span> <span class="o">==</span> <span class="s1">&#39;gsm&#39;</span><span class="p">:</span>
        <span class="c1"># compute GSM base vectors</span>
        <span class="n">base_1</span><span class="p">,</span> <span class="n">base_2</span><span class="p">,</span> <span class="n">base_3</span> <span class="o">=</span> <span class="n">basevectors_gsm</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">dipole</span><span class="o">=</span><span class="n">dipole</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">reference</span> <span class="o">==</span> <span class="s1">&#39;sm&#39;</span><span class="p">:</span>
        <span class="c1"># compute SM base vectors</span>
        <span class="n">base_1</span><span class="p">,</span> <span class="n">base_2</span><span class="p">,</span> <span class="n">base_3</span> <span class="o">=</span> <span class="n">basevectors_sm</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">dipole</span><span class="o">=</span><span class="n">dipole</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">reference</span> <span class="o">==</span> <span class="s1">&#39;mag&#39;</span><span class="p">:</span>
        <span class="c1"># compute centered dipole base vectors</span>
        <span class="n">base_1</span><span class="p">,</span> <span class="n">base_2</span><span class="p">,</span> <span class="n">base_3</span> <span class="o">=</span> <span class="n">basevectors_mag</span><span class="p">()</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unknown target reference system. Use one of &#39;</span>
                         <span class="s1">&#39;{&quot;gsm&quot;, &quot;sm&quot;, &quot;mag&quot;}.&#39;</span><span class="p">)</span>

    <span class="n">theta_ref</span><span class="p">,</span> <span class="n">phi_ref</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">matrix_geo_to_base</span><span class="p">(</span>
        <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">base_1</span><span class="p">,</span> <span class="n">base_2</span><span class="p">,</span> <span class="n">base_3</span><span class="p">,</span> <span class="n">inverse</span><span class="o">=</span><span class="n">inverse</span><span class="p">)</span>

    <span class="n">B_theta_ref</span> <span class="o">=</span> <span class="n">R</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">B_theta</span> <span class="o">+</span> <span class="n">R</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">B_phi</span>
    <span class="n">B_phi_ref</span> <span class="o">=</span> <span class="n">R</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">B_theta</span> <span class="o">+</span> <span class="n">R</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">B_phi</span>

    <span class="k">return</span> <span class="n">theta_ref</span><span class="p">,</span> <span class="n">phi_ref</span><span class="p">,</span> <span class="n">B_theta_ref</span><span class="p">,</span> <span class="n">B_phi_ref</span></div>


<div class="viewcode-block" id="center_azimuth"><a class="viewcode-back" href="../../functions/chaosmagpy.coordinate_utils.center_azimuth.html#chaosmagpy.coordinate_utils.center_azimuth">[docs]</a><span class="k">def</span> <span class="nf">center_azimuth</span><span class="p">(</span><span class="n">phi</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Project azimuth angles in degrees to the semi-open interval</span>
<span class="sd">    :math:`(-180^\\circ, 180^\\circ]`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    phi : ndarray, float</span>
<span class="sd">        Azimuth in degrees.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    phi : ndarray, float</span>
<span class="sd">        Azimuth in degrees on the semi-open interval</span>
<span class="sd">        :math:`(-180^\\circ, 180^\\circ]`.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">phi</span> <span class="o">=</span> <span class="n">phi</span> <span class="o">%</span> <span class="mf">360.</span>
    <span class="k">try</span><span class="p">:</span>  <span class="c1"># works for ndarray</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">phi</span> <span class="o">&gt;</span> <span class="mf">180.</span><span class="p">,</span> <span class="n">phi</span> <span class="o">-</span> <span class="mf">360.</span><span class="p">,</span> <span class="n">phi</span><span class="p">)</span>  <span class="c1"># centered around prime</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>  <span class="c1"># catch error if float</span>
        <span class="n">phi</span> <span class="o">+=</span> <span class="o">-</span><span class="mf">360.</span> <span class="k">if</span> <span class="n">phi</span> <span class="o">&gt;</span> <span class="mf">180.</span> <span class="k">else</span> <span class="mf">0.</span>

    <span class="k">return</span> <span class="n">phi</span></div>


<div class="viewcode-block" id="local_time"><a class="viewcode-back" href="../../functions/chaosmagpy.coordinate_utils.local_time.html#chaosmagpy.coordinate_utils.local_time">[docs]</a><span class="k">def</span> <span class="nf">local_time</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">phi</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute local time from the azimuthal distance to prime meridian.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    time : float, ndarray</span>
<span class="sd">        Time given as modified Julian date.</span>
<span class="sd">    phi : float, ndarray</span>
<span class="sd">        Azimuth in degrees.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    local : ndarray</span>
<span class="sd">        Local time [0, 24).</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">remainder</span><span class="p">(</span><span class="n">time</span> <span class="o">+</span> <span class="n">phi</span><span class="o">/</span><span class="mi">360</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">24</span></div>


<div class="viewcode-block" id="q_response_1D"><a class="viewcode-back" href="../../functions/chaosmagpy.coordinate_utils.q_response_1D.html#chaosmagpy.coordinate_utils.q_response_1D">[docs]</a><span class="k">def</span> <span class="nf">q_response_1D</span><span class="p">(</span><span class="n">periods</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the response for a spherically layered conductor in an</span>
<span class="sd">    inducing external field of a single spherical harmonic degree.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    periods : ndarray or float, shape (m,)</span>
<span class="sd">        Oscillation period of the inducing field in seconds.</span>
<span class="sd">    sigma : ndarray, shape (k,)</span>
<span class="sd">        Conductivity of spherical shells, starting with the outermost in (S/m).</span>
<span class="sd">    radius : ndarray, shape (k,)</span>
<span class="sd">        Radius of the interfaces in between the layers, starting with outermost</span>
<span class="sd">        layer in kilometers (i.e. conductor surface, see Notes).</span>
<span class="sd">    n : int</span>
<span class="sd">        Spherical degree of inducing external field.</span>
<span class="sd">    kind : {&#39;quadratic&#39;, &#39;constant&#39;}, optional</span>
<span class="sd">        Approximation for &quot;quadratic&quot; layers (layers of sigma with inverse</span>
<span class="sd">        quadratic dependence on radius) or &quot;constant&quot; layers (layers of</span>
<span class="sd">        constant sigma, last layer will be set to infinity irrespective of its</span>
<span class="sd">        value in ``sigma[-1]``).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    C : ndarray, shape (m,)</span>
<span class="sd">        C-response in (km), complex.</span>
<span class="sd">    rho_a : ndarray, shape (m,)</span>
<span class="sd">        Electrical surface resistance in (:math:`\\Omega m`).</span>
<span class="sd">    phi : ndarray, shape (m,)</span>
<span class="sd">        Proportional to phase angle of C-response in degrees.</span>
<span class="sd">    Q : ndarray, shape (m,)</span>
<span class="sd">        Q-response, complex.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    Option ``kind=&#39;quadratic&#39;``:</span>
<span class="sd">        The following shows how the conductivity is defined in the sphercial</span>
<span class="sd">        shells:</span>

<span class="sd">        | ``radius[0]`` &gt;= `r` &gt; ``radius[1]``: \</span>
<span class="sd">            ``sigma[0]`` * ( ``radius[0]`` / `r` ) * * 2</span>
<span class="sd">        | ``radius[1]`` &gt;= `r` &gt; ``radius[2]``: \</span>
<span class="sd">            ``sigma[1]`` * ( ``radius[1]`` / `r` ) * * 2</span>
<span class="sd">        | ...</span>
<span class="sd">        | ``radius[k-1]`` &gt;= `r` &gt; 0 : \</span>
<span class="sd">            ``sigma[k-1]`` * ( ``radius[k-1]`` / `r` ) * * 2</span>

<span class="sd">        Courtesy of A. Grayver. Code based on Kuvshinov &amp; Semenov (2012).</span>

<span class="sd">    Option ``kind=&#39;constant&#39;``:</span>
<span class="sd">        The following shows how the conductivity is defined in the sphercial</span>
<span class="sd">        shells:</span>

<span class="sd">        | ``radius[0]`` &gt;= `r` &gt; ``radius[1]``: ``sigma[0]``</span>
<span class="sd">        | ``radius[1]`` &gt;= `r` &gt; ``radius[2]``: ``sigma[1]``</span>
<span class="sd">        | ...</span>
<span class="sd">        | ``radius[k-1]`` &gt;= `r` &gt; 0 : ``sigma[k-1]`` = ``np.inf`` \</span>
<span class="sd">            (:math:`\\sigma` = `\\inf`)</span>

<span class="sd">        There are ``k`` sphercial shells of uniform conductivity with</span>
<span class="sd">        radius in (km) and conductivity :math:`\\sigma` in (S/m).</span>

<span class="sd">        The last shell corresponds to the sphercial core whose conductivity is</span>
<span class="sd">        set to infinity regardless of the provided ``sigma[-1]``.</span>

<span class="sd">        The program should work also for very small periods, where it</span>
<span class="sd">        models the response of a layered plane conductor</span>

<span class="sd">        | Python version: August 2018, Clemens Kloss</span>
<span class="sd">        | Matlab version: November 2000, Nils Olsen</span>
<span class="sd">        | Original Fortran program: Peter Weidelt</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">kind</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">kind</span> <span class="o">=</span> <span class="s1">&#39;quadratic&#39;</span>

    <span class="n">periods</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">periods</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>  <span class="c1"># ensure numpy array</span>
    <span class="k">if</span> <span class="n">periods</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input ``periods`` must be a vector.&quot;</span><span class="p">)</span>

    <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>  <span class="c1"># ensure numpy array</span>
    <span class="k">if</span> <span class="n">sigma</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Conductivity ``sigma`` must be a vector.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;constant&#39;</span><span class="p">:</span>

        <span class="n">nl</span> <span class="o">=</span> <span class="n">radius</span><span class="o">.</span><span class="n">size</span><span class="o">-</span><span class="mi">2</span>  <span class="c1"># index of last layer, there are nl+1 layers</span>

        <span class="n">eps</span> <span class="o">=</span> <span class="mf">1.0e-10</span>
        <span class="n">zlimit</span> <span class="o">=</span> <span class="mi">3</span>

        <span class="n">fac1</span> <span class="o">=</span> <span class="n">factorial</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="n">fac2</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">n</span> <span class="o">*</span> <span class="n">fac1</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># initialze helpers variables and output</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">periods</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="n">pd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="n">qd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">counter</span><span class="p">,</span> <span class="n">period</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">periods</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">il</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nl</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>  <span class="c1"># runs over nl...0</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">8.0e-7</span> <span class="o">*</span> <span class="mf">1.0</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">sigma</span><span class="p">[</span><span class="n">il</span><span class="p">]</span> <span class="o">/</span> <span class="n">period</span><span class="p">)</span>
                <span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span><span class="o">*</span><span class="n">radius</span><span class="p">[</span><span class="n">il</span><span class="p">]</span><span class="o">*</span><span class="mi">1000</span>
                <span class="n">z</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span><span class="o">*</span><span class="n">radius</span><span class="p">[</span><span class="n">il</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="mi">1000</span>

                <span class="c1"># calculate spherical bessel functions with small argument</span>
                <span class="c1"># by power series (abramowitz &amp; Stegun 10.2.5, 10.2.6</span>
                <span class="c1"># and 10.2.4):</span>

                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">zlimit</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                        <span class="n">p</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span>
                        <span class="n">q</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span>
                        <span class="n">pd</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span>
                        <span class="n">qd</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                        <span class="n">zz</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="mi">2</span>

                        <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="n">dp</span> <span class="o">=</span> <span class="mi">1</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span>
                        <span class="n">dq</span> <span class="o">=</span> <span class="mi">1</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span>
                        <span class="k">while</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">dp</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">eps</span> <span class="ow">or</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dq</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">eps</span><span class="p">):</span>
                            <span class="n">dp</span> <span class="o">=</span> <span class="n">dp</span> <span class="o">*</span> <span class="n">zz</span> <span class="o">/</span> <span class="n">j</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="p">)</span>
                            <span class="n">dq</span> <span class="o">=</span> <span class="n">dq</span> <span class="o">*</span> <span class="n">zz</span> <span class="o">/</span> <span class="n">j</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="p">)</span>
                            <span class="n">p</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">+</span> <span class="n">dp</span>
                            <span class="n">q</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">+</span> <span class="n">dq</span>
                            <span class="n">pd</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">+</span> <span class="n">dp</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">j</span><span class="o">+</span><span class="n">n</span><span class="p">)</span>
                            <span class="n">qd</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">qd</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">+</span> <span class="n">dq</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">j</span><span class="o">-</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                            <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>

                        <span class="n">p</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">*</span> <span class="n">z</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">**</span><span class="n">n</span> <span class="o">/</span> <span class="n">fac1</span>
                        <span class="n">q</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">*</span> <span class="n">z</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">fac2</span>
                        <span class="n">q</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">-</span><span class="n">q</span><span class="p">[</span><span class="n">m</span><span class="p">])</span>
                        <span class="n">pd</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">*</span> <span class="n">z</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">**</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">fac1</span>
                        <span class="n">qd</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">qd</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">*</span> <span class="n">z</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">fac2</span>
                        <span class="n">qd</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">pd</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">-</span><span class="n">qd</span><span class="p">[</span><span class="n">m</span><span class="p">])</span>

                    <span class="n">v1</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">v2</span> <span class="o">=</span> <span class="n">pd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">v3</span> <span class="o">=</span> <span class="n">pd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">v4</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">v5</span> <span class="o">=</span> <span class="n">qd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">v6</span> <span class="o">=</span> <span class="n">qd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># calculate spherical bessel functions with large argument</span>
                    <span class="c1"># the exponential behaviour is split off and treated</span>
                    <span class="c1"># separately (abramowitz &amp; stegun 10.2.9 and 10.2.15)</span>
                    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                        <span class="n">zz</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">z</span><span class="p">[</span><span class="n">m</span><span class="p">]</span>
                        <span class="n">rm</span> <span class="o">=</span> <span class="mi">1</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span>
                        <span class="n">rp</span> <span class="o">=</span> <span class="mi">1</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span>
                        <span class="n">rmd</span> <span class="o">=</span> <span class="mi">1</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span>
                        <span class="n">rpd</span> <span class="o">=</span> <span class="mi">1</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span>
                        <span class="n">d</span> <span class="o">=</span> <span class="mi">1</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span>
                        <span class="n">sg</span> <span class="o">=</span> <span class="mi">1</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span>
                        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                            <span class="n">d</span> <span class="o">=</span> <span class="n">d</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">-</span><span class="n">j</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="n">j</span><span class="p">)</span> <span class="o">/</span> <span class="n">j</span> <span class="o">/</span> <span class="n">zz</span>
                            <span class="n">sg</span> <span class="o">=</span> <span class="o">-</span><span class="n">sg</span>
                            <span class="n">rp</span> <span class="o">=</span> <span class="n">rp</span> <span class="o">+</span> <span class="n">d</span>
                            <span class="n">rm</span> <span class="o">=</span> <span class="n">rm</span> <span class="o">+</span> <span class="n">sg</span><span class="o">*</span><span class="n">d</span>
                            <span class="n">rmd</span> <span class="o">=</span> <span class="n">rmd</span> <span class="o">+</span> <span class="n">sg</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                            <span class="n">rpd</span> <span class="o">=</span> <span class="n">rpd</span> <span class="o">+</span> <span class="n">d</span><span class="o">*</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

                        <span class="n">e</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">z</span><span class="p">[</span><span class="n">m</span><span class="p">])</span>
                        <span class="n">p</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">rm</span> <span class="o">-</span> <span class="n">sg</span><span class="o">*</span><span class="n">rp</span><span class="o">*</span><span class="n">e</span><span class="p">)</span> <span class="o">/</span> <span class="n">zz</span>
                        <span class="n">q</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="n">zz</span><span class="p">)</span> <span class="o">*</span> <span class="n">rp</span>
                        <span class="n">pd</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">rm</span> <span class="o">+</span> <span class="n">sg</span><span class="o">*</span><span class="n">rp</span><span class="o">*</span><span class="n">e</span><span class="p">)</span> <span class="o">/</span>
                                 <span class="n">zz</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">rmd</span> <span class="o">-</span> <span class="n">sg</span><span class="o">*</span><span class="n">rpd</span><span class="o">*</span><span class="n">e</span><span class="p">)</span> <span class="o">/</span> <span class="n">zz</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                        <span class="n">qd</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">q</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">rpd</span> <span class="o">/</span> <span class="n">zz</span><span class="o">**</span><span class="mi">2</span>

                    <span class="n">e</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">z</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                    <span class="n">v1</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">e</span>
                    <span class="n">v2</span> <span class="o">=</span> <span class="n">pd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">v3</span> <span class="o">=</span> <span class="n">pd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">e</span>
                    <span class="n">v4</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">e</span>
                    <span class="n">v5</span> <span class="o">=</span> <span class="n">qd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">e</span>
                    <span class="n">v6</span> <span class="o">=</span> <span class="n">qd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">il</span> <span class="o">==</span> <span class="n">nl</span><span class="p">):</span>
                    <span class="n">b</span> <span class="o">=</span> <span class="n">k</span><span class="o">*</span><span class="p">(</span><span class="n">v2</span> <span class="o">-</span> <span class="n">v5</span><span class="o">*</span><span class="n">v1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">v4</span><span class="o">*</span><span class="n">v1</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">k</span><span class="o">*</span><span class="p">((</span><span class="n">v2</span> <span class="o">-</span> <span class="n">v5</span><span class="o">*</span><span class="n">v1</span><span class="p">)</span><span class="o">*</span><span class="n">b</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="p">(</span><span class="n">v5</span><span class="o">*</span><span class="n">v3</span><span class="o">-</span><span class="n">v2</span><span class="o">*</span><span class="n">v6</span><span class="p">))</span> <span class="o">/</span>
                         <span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">v4</span><span class="o">*</span><span class="n">v1</span><span class="p">)</span><span class="o">*</span><span class="n">b</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="p">(</span><span class="n">v4</span><span class="o">*</span><span class="n">v3</span> <span class="o">-</span> <span class="n">v6</span><span class="p">)))</span>

            <span class="n">C</span><span class="p">[</span><span class="n">counter</span><span class="p">]</span> <span class="o">=</span> <span class="n">radius</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">1000</span><span class="o">*</span><span class="n">radius</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">)</span>  <span class="c1"># C in km</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Finished </span><span class="si">{:.1f}</span><span class="s2">%&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="p">(</span><span class="n">counter</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">periods</span><span class="o">.</span><span class="n">size</span><span class="o">*</span><span class="mi">100</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\r</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

        <span class="c1"># if nargout &gt; 1</span>
        <span class="n">rho_a</span> <span class="o">=</span> <span class="mf">1e-7</span><span class="o">*</span><span class="mi">8</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="n">periods</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">C</span><span class="o">*</span><span class="mi">1000</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="mi">90</span> <span class="o">+</span> <span class="mf">57.3</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="n">n</span><span class="o">/</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">C</span><span class="o">/</span><span class="n">radius</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">n</span><span class="o">*</span><span class="n">C</span><span class="o">/</span><span class="n">radius</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;quadratic&#39;</span><span class="p">:</span>

        <span class="n">radius</span> <span class="o">=</span> <span class="mf">1e3</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">radius</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="c1"># constants</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="mi">4</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="mf">1e-7</span>

        <span class="n">omega</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="mf">1.0</span><span class="n">j</span><span class="o">/</span><span class="n">periods</span>

        <span class="c1"># Number of layers</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">sigma</span><span class="o">.</span><span class="n">size</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">omega</span><span class="o">.</span><span class="n">size</span>

        <span class="c1"># Preallocate</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">M</span><span class="p">,</span> <span class="n">N</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>

        <span class="c1"># values for inner sphere, r = N (core)</span>
        <span class="n">qk</span> <span class="o">=</span> <span class="o">-</span><span class="n">omega</span><span class="o">*</span><span class="n">mu</span><span class="o">*</span><span class="n">radius</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">bk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">n</span><span class="o">+</span><span class="mf">0.5</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">qk</span><span class="o">*</span><span class="n">sigma</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">radius</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">bkp</span> <span class="o">=</span> <span class="n">bk</span> <span class="o">+</span> <span class="mf">0.5</span>
        <span class="n">Y</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">bkp</span><span class="o">/</span><span class="n">qk</span>

        <span class="c1"># Loop over all layers above core (from core to surface)</span>
        <span class="c1"># from before last (N-2) to first (0)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="c1"># Compute temporary scalars</span>
            <span class="n">qk</span> <span class="o">=</span> <span class="o">-</span><span class="n">omega</span><span class="o">*</span><span class="n">mu</span><span class="o">*</span><span class="n">radius</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="n">bk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">n</span><span class="o">+</span><span class="mf">0.5</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">qk</span><span class="o">*</span><span class="n">sigma</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">radius</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
            <span class="n">bkp</span> <span class="o">=</span> <span class="n">bk</span> <span class="o">+</span> <span class="mf">0.5</span>
            <span class="n">bkm</span> <span class="o">=</span> <span class="n">bk</span> <span class="o">-</span> <span class="mf">0.5</span>

            <span class="n">etak</span> <span class="o">=</span> <span class="n">radius</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">/</span><span class="n">radius</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">zetak</span> <span class="o">=</span> <span class="n">etak</span><span class="o">**</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">bk</span><span class="p">)</span>

            <span class="n">tauk</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">zetak</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">+</span> <span class="n">zetak</span><span class="p">)</span>
            <span class="c1"># handling of precision overflow due to high frequencies</span>
            <span class="n">tauk</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">tauk</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.</span>

            <span class="n">qk</span> <span class="o">=</span> <span class="o">-</span><span class="n">omega</span><span class="o">*</span><span class="n">mu</span><span class="o">*</span><span class="n">radius</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="n">qk1</span> <span class="o">=</span> <span class="o">-</span><span class="n">omega</span><span class="o">*</span><span class="n">mu</span><span class="o">*</span><span class="n">radius</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">qY</span> <span class="o">=</span> <span class="n">qk1</span><span class="o">*</span><span class="n">Y</span><span class="p">[:,</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># Admittance for this layer</span>
            <span class="n">Y</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">qk</span><span class="o">*</span><span class="p">(</span><span class="n">qY</span><span class="o">*</span><span class="p">(</span><span class="n">bk</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">tauk</span><span class="p">)</span><span class="o">+</span><span class="n">bkp</span><span class="o">*</span><span class="n">bkm</span><span class="o">*</span><span class="n">tauk</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">bk</span><span class="o">+</span><span class="n">tauk</span><span class="o">*</span><span class="p">(</span><span class="mf">0.5</span><span class="o">+</span><span class="n">qY</span><span class="p">))</span>

        <span class="c1"># Compute the C-response (in km)</span>
        <span class="n">C</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">omega</span><span class="o">*</span><span class="n">mu</span><span class="o">*</span><span class="n">Y</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="mf">1e3</span>

        <span class="n">rho_a</span> <span class="o">=</span> <span class="n">mu</span><span class="o">*</span><span class="n">omega</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">C</span><span class="o">*</span><span class="mi">1000</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>  <span class="c1"># rho_a in (Ohm*m)</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="mi">90</span> <span class="o">+</span> <span class="mf">57.3</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>  <span class="c1"># phase phi in degrees</span>

        <span class="c1"># Q-response</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="n">n</span><span class="o">/</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">C</span><span class="o">/</span><span class="p">(</span><span class="n">radius</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mf">1e3</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">n</span><span class="o">*</span><span class="n">C</span><span class="o">/</span><span class="p">(</span><span class="n">radius</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mf">1e3</span><span class="p">))</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Unknown option &quot;kind=</span><span class="si">{</span><span class="n">kind</span><span class="si">}</span><span class="s1">&quot;.&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">C</span><span class="p">,</span> <span class="n">rho_a</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">Q</span></div>


<div class="viewcode-block" id="q_response"><a class="viewcode-back" href="../../functions/chaosmagpy.coordinate_utils.q_response.html#chaosmagpy.coordinate_utils.q_response">[docs]</a><span class="k">def</span> <span class="nf">q_response</span><span class="p">(</span><span class="n">frequency</span><span class="p">,</span> <span class="n">nmax</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the Q-response for a given conductivity model of Earth.</span>

<span class="sd">    The conductivity model is loaded during the computation from</span>
<span class="sd">    ``basicConfig[&#39;file.Earth_conductivity&#39;]``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    frequency : ndarray, shape (N,)</span>
<span class="sd">        Vector of `N` frequencies (1/sec) for which to compute the Q-response.</span>
<span class="sd">    nmax : int</span>
<span class="sd">        Maximum spherical harmonic degree of inducing field.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    q_response : ndarray, shape (nmax, N)</span>
<span class="sd">        Q-response for every frequency and harmonic degree of inducing</span>
<span class="sd">        field. Index 0 corresponds to degree 1, index 1 corresponds to degree</span>
<span class="sd">        2, and so on.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># load conductivity model</span>
    <span class="n">filepath</span> <span class="o">=</span> <span class="n">basicConfig</span><span class="p">[</span><span class="s1">&#39;file.Earth_conductivity&#39;</span><span class="p">]</span>
    <span class="n">sigma_model</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>

    <span class="n">radius_ref</span> <span class="o">=</span> <span class="mf">6371.2</span>  <span class="c1"># reference radius in km</span>

    <span class="c1"># unpack file: depth and layer conductivity</span>
    <span class="c1"># convert depth to radius</span>
    <span class="n">sigma_radius</span> <span class="o">=</span> <span class="n">radius_ref</span> <span class="o">-</span> <span class="n">sigma_model</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>

    <span class="c1"># conductivity profile</span>
    <span class="n">sigma</span> <span class="o">=</span> <span class="n">sigma_model</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>

    <span class="c1"># find all harmonic terms</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">frequency</span> <span class="o">&gt;</span> <span class="mf">0.0</span>

    <span class="n">periods</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">frequency</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

    <span class="n">q_response</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nmax</span><span class="p">,</span> <span class="n">frequency</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nmax</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Calculating Q-response for degree </span><span class="si">{:}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="c1"># compute Q-response for conductivity model and given degree n</span>
        <span class="n">C_n</span><span class="p">,</span> <span class="n">rho_n</span><span class="p">,</span> <span class="n">phi_n</span><span class="p">,</span> <span class="n">Q_n</span> <span class="o">=</span> <span class="n">q_response_1D</span><span class="p">(</span>
            <span class="n">periods</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">sigma_radius</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;quadratic&#39;</span><span class="p">)</span>
        <span class="n">q_response</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">Q_n</span>  <span class="c1"># index 0: degree 1, index 1: degree 2, ...</span>

    <span class="k">return</span> <span class="n">q_response</span></div>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h3><a href="../../index.html">Table of Contents</a></h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../readme.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gallery/index.html">Gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../configuration.html">Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../references.html">API References</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../license.html">License</a></li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="nav-item nav-item-0"><a href="../../index.html">ChaosMagPy 0.11 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">chaosmagpy.coordinate_utils</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2021, Clemens Kloss.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.1.2.
    </div>
  </body>
</html>