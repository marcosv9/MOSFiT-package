
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>chaosmagpy.model_utils &#8212; ChaosMagPy 0.11 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/nature.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/gallery.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/gallery-dataframe.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/gallery-rendered-html.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="nav-item nav-item-0"><a href="../../index.html">ChaosMagPy 0.11 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">chaosmagpy.model_utils</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for chaosmagpy.model_utils</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module provide functions for building the CHAOS model and geomagnetic</span>
<span class="sd">field models in general.</span>

<span class="sd">.. autosummary::</span>
<span class="sd">    :toctree: functions</span>

<span class="sd">    design_matrix</span>
<span class="sd">    design_gauss</span>
<span class="sd">    colloc_matrix</span>
<span class="sd">    augment_breaks</span>
<span class="sd">    pp_from_bspline</span>
<span class="sd">    synth_from_pp</span>
<span class="sd">    synth_values</span>
<span class="sd">    legendre_poly</span>
<span class="sd">    power_spectrum</span>
<span class="sd">    degree_correlation</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">chaosmagpy.config_utils</span> <span class="kn">import</span> <span class="n">basicConfig</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">BSpline</span><span class="p">,</span> <span class="n">PPoly</span>


<div class="viewcode-block" id="design_matrix"><a class="viewcode-back" href="../../functions/chaosmagpy.model_utils.design_matrix.html#chaosmagpy.model_utils.design_matrix">[docs]</a><span class="k">def</span> <span class="nf">design_matrix</span><span class="p">(</span><span class="n">knots</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">n_tdep</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span>
                  <span class="n">n_static</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns matrices that connect radial, colatitude and azimuthal field</span>
<span class="sd">    components on a grid with `radius`, `theta` (colatitude) and `phi`</span>
<span class="sd">    to the spherical harmonics expansion of a potential.</span>

<span class="sd">    The potential is time-dependent on large length-scales (`n` &lt;= `n_tdep`)</span>
<span class="sd">    and static on small length-scales (`n_tdep` &lt; `n` &lt;= `n_static`). The</span>
<span class="sd">    time-dependent part uses a B-spline representation of order `k`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    knots : ndarray, shape &gt;= (k+1,)</span>
<span class="sd">        Knot vector with adequate endpoint multiplicity.</span>
<span class="sd">    order : int, positive</span>
<span class="sd">        Order `k` of B-spline basis functions (4 = cubic).</span>
<span class="sd">    n_tdep : int, positive</span>
<span class="sd">        Maximum degree of the time-dependent field.</span>
<span class="sd">    time : ndarray, shape (N,)</span>
<span class="sd">        Time vector of the `N` data points in days.</span>
<span class="sd">    radius : ndarray, shape (N,)</span>
<span class="sd">        Radius vector of the `N` data points in kilometers.</span>
<span class="sd">    theta : ndarray, shape (N,)</span>
<span class="sd">        Data colatitude vector in degrees :math:`[0^\\circ,180^\\circ]`.</span>
<span class="sd">    phi : ndarray, shape (N,)</span>
<span class="sd">        Data longitude vector in degrees.</span>
<span class="sd">    n_static : int, positive, optional</span>
<span class="sd">        Maximum degree of static field (default is ``None``,</span>
<span class="sd">        `n_static` &gt; `n_tdep`).</span>
<span class="sd">    source : {&#39;internal&#39;, &#39;external&#39;}, optional</span>
<span class="sd">        Magnetic field source (default is internal).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    G_radius, G_theta, G_phi : ndarray, shape (N, ...)</span>
<span class="sd">        Forward matrix for :math:`B_r`, :math:`B_{\\theta}` and</span>
<span class="sd">        :math:`B_{\\phi}`.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If degree of static field is smaller than the degree of the time-dep.</span>
<span class="sd">        field. In order to exclude the static field and obtain a purely</span>
<span class="sd">        time-dependent potential, use optional argument ``n_static=None`` or</span>
<span class="sd">        leave out completely.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    design_gauss</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">assert</span> <span class="n">time</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">radius</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">theta</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">phi</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">assert</span> <span class="n">time</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">180.</span>

    <span class="n">n_data</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">size</span>  <span class="c1"># number of data points</span>

    <span class="k">if</span> <span class="n">n_static</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">n_static</span> <span class="o">&lt;</span> <span class="n">n_tdep</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Degree of static field must be greater than &quot;</span>
                             <span class="s2">&quot;degree of time-dependent field.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">n_static</span> <span class="o">==</span> <span class="n">n_tdep</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Static and time-dependent field are of same &quot;</span>
                          <span class="s2">&quot;degree. Ignoring static field.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">n_static</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">n_static</span> <span class="o">=</span> <span class="n">n_tdep</span>

    <span class="k">if</span> <span class="n">source</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">source</span> <span class="o">=</span> <span class="s1">&#39;internal&#39;</span>

    <span class="n">n_coeff_tdep</span> <span class="o">=</span> <span class="n">n_tdep</span> <span class="o">*</span> <span class="p">(</span><span class="n">n_tdep</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># number of t-dep field coefficients</span>
    <span class="n">n_coeff_static</span> <span class="o">=</span> <span class="n">n_static</span> <span class="o">*</span> <span class="p">(</span><span class="n">n_static</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># number of static field coeff</span>

    <span class="c1"># compute matrices that connect harmonics expansion with field values</span>
    <span class="n">A_radius</span><span class="p">,</span> <span class="n">A_theta</span><span class="p">,</span> <span class="n">A_phi</span> <span class="o">=</span> <span class="n">design_gauss</span><span class="p">(</span><span class="n">radius</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span>
                                            <span class="n">nmax</span><span class="o">=</span><span class="n">n_static</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="n">source</span><span class="p">)</span>

    <span class="c1"># compute collocation matrix of B-spline segments</span>
    <span class="n">collmat</span> <span class="o">=</span> <span class="n">colloc_matrix</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">knots</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>
    <span class="n">n_segment</span> <span class="o">=</span> <span class="n">collmat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># number of B-spline basis functions</span>

    <span class="c1"># allocate memory for output matrices</span>
    <span class="n">G_radius</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n_data</span><span class="p">,</span> <span class="p">(</span><span class="n">n_segment</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">n_coeff_tdep</span>
                        <span class="o">+</span> <span class="n">n_coeff_static</span><span class="p">))</span>
    <span class="n">G_theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n_data</span><span class="p">,</span> <span class="p">(</span><span class="n">n_segment</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">n_coeff_tdep</span> <span class="o">+</span> <span class="n">n_coeff_static</span><span class="p">))</span>
    <span class="n">G_phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n_data</span><span class="p">,</span> <span class="p">(</span><span class="n">n_segment</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">n_coeff_tdep</span> <span class="o">+</span> <span class="n">n_coeff_static</span><span class="p">))</span>

    <span class="n">n_col</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># counter for columns</span>
    <span class="k">for</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_coeff_tdep</span><span class="p">):</span>
        <span class="c1"># for each time-dependent expansion coefficient, multiply with</span>
        <span class="c1"># collocation matrix use broadcasting to match shapes</span>
        <span class="n">G_radius</span><span class="p">[:,</span> <span class="n">n_col</span><span class="p">:</span><span class="n">n_col</span><span class="o">+</span><span class="n">n_segment</span><span class="p">]</span> <span class="o">=</span> <span class="n">A_radius</span><span class="p">[:,</span> <span class="n">coeff</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">collmat</span>
        <span class="n">G_theta</span><span class="p">[:,</span> <span class="n">n_col</span><span class="p">:</span><span class="n">n_col</span><span class="o">+</span><span class="n">n_segment</span><span class="p">]</span> <span class="o">=</span> <span class="n">A_theta</span><span class="p">[:,</span> <span class="n">coeff</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">collmat</span>
        <span class="n">G_phi</span><span class="p">[:,</span> <span class="n">n_col</span><span class="p">:</span><span class="n">n_col</span><span class="o">+</span><span class="n">n_segment</span><span class="p">]</span> <span class="o">=</span> <span class="n">A_phi</span><span class="p">[:,</span> <span class="n">coeff</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">collmat</span>

        <span class="n">n_col</span> <span class="o">+=</span> <span class="n">n_segment</span>

    <span class="c1"># add static background field</span>
    <span class="n">G_radius</span><span class="p">[:,</span> <span class="n">n_col</span><span class="p">:]</span> <span class="o">=</span> <span class="n">A_radius</span><span class="p">[:,</span> <span class="n">n_coeff_tdep</span><span class="p">:</span><span class="n">n_coeff_static</span><span class="p">]</span>
    <span class="n">G_theta</span><span class="p">[:,</span> <span class="n">n_col</span><span class="p">:]</span> <span class="o">=</span> <span class="n">A_theta</span><span class="p">[:,</span> <span class="n">n_coeff_tdep</span><span class="p">:</span><span class="n">n_coeff_static</span><span class="p">]</span>
    <span class="n">G_phi</span><span class="p">[:,</span> <span class="n">n_col</span><span class="p">:]</span> <span class="o">=</span> <span class="n">A_phi</span><span class="p">[:,</span> <span class="n">n_coeff_tdep</span><span class="p">:</span><span class="n">n_coeff_static</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">G_radius</span><span class="p">,</span> <span class="n">G_theta</span><span class="p">,</span> <span class="n">G_phi</span></div>


<div class="viewcode-block" id="colloc_matrix"><a class="viewcode-back" href="../../functions/chaosmagpy.model_utils.colloc_matrix.html#chaosmagpy.model_utils.colloc_matrix">[docs]</a><span class="k">def</span> <span class="nf">colloc_matrix</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">knots</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">deriv</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create collocation matrix of a univariate function on `x` in terms  of a</span>
<span class="sd">    B-spline representation of order `k`.</span>

<span class="sd">    The computation of the splines is based on the scipy-package.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : ndarray, shape (N,)</span>
<span class="sd">        `N` points to evaluate the B-spline at.</span>
<span class="sd">    knots : ndarray, shape &gt;= (k+1,)</span>
<span class="sd">        Vector of knots derived from breaks (with appropriate endpoint</span>
<span class="sd">        multiplicity).</span>
<span class="sd">    order : int, positive</span>
<span class="sd">        Order `k` of the B-spline (4 = cubic).</span>
<span class="sd">    deriv: int, positive, optional</span>
<span class="sd">        Derivative of the B-spline partition (defaults to 0).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    collmat : ndarray, shape (N, n-k)</span>
<span class="sd">        Collocation matrix, `n` is the size of `knots`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    augment_breaks</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">deriv</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">deriv</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="n">deriv</span> <span class="o">&gt;=</span> <span class="n">order</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">max</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">knots</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="n">order</span><span class="p">))</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># create spline using scipy.interpolate</span>
        <span class="n">coll</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">max</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">knots</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="n">order</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">knots</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="n">order</span><span class="p">):</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">knots</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="n">order</span><span class="p">)</span>
            <span class="n">c</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>

            <span class="n">b</span> <span class="o">=</span> <span class="n">BSpline</span><span class="o">.</span><span class="n">construct_fast</span><span class="p">(</span><span class="n">knots</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">order</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">extrapolate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="n">coll</span><span class="p">[:,</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">nu</span><span class="o">=</span><span class="n">deriv</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">coll</span></div>


<div class="viewcode-block" id="augment_breaks"><a class="viewcode-back" href="../../functions/chaosmagpy.model_utils.augment_breaks.html#chaosmagpy.model_utils.augment_breaks">[docs]</a><span class="k">def</span> <span class="nf">augment_breaks</span><span class="p">(</span><span class="n">breaks</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Augment a vector of break points and return the knot vector for a</span>
<span class="sd">    B-spline representation of order `k`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    breaks: ndarray, shape (n,)</span>
<span class="sd">        1-D array, containing `n` break points (without endpoint repeats).</span>
<span class="sd">    order: int, positive</span>
<span class="sd">        Order `k` of B-spline (4 = cubic).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    knots: ndarray, shape (n+2k-2,)</span>
<span class="sd">        1-D array with `k`-times repeated copies of the `breaks`-vector</span>
<span class="sd">        endpoints ``breaks[0]`` and ``breaks[-1]``.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">breaks</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">breaks</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Breaks must be a 1-D array.&quot;</span><span class="p">)</span>

    <span class="n">degree</span> <span class="o">=</span> <span class="n">order</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">breaks</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">*</span><span class="n">degree</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">breaks</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">breaks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span><span class="o">*</span><span class="n">degree</span><span class="p">)</span></div>


<div class="viewcode-block" id="pp_from_bspline"><a class="viewcode-back" href="../../functions/chaosmagpy.model_utils.pp_from_bspline.html#chaosmagpy.model_utils.pp_from_bspline">[docs]</a><span class="k">def</span> <span class="nf">pp_from_bspline</span><span class="p">(</span><span class="n">coeffs</span><span class="p">,</span> <span class="n">knots</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a piecewise polynomial from a BSpline representation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    coeffs : ndarray, shape (M, D)</span>
<span class="sd">        Bspline coefficients for the `M` B-splines parameterizing</span>
<span class="sd">        `D` dimensions.</span>
<span class="sd">    knots : ndarray, shape (N,)</span>
<span class="sd">        B-spline knots. The knots must have the full endpoint multiplicity.</span>
<span class="sd">        Zero-pad spline coefficients if needed.</span>
<span class="sd">    order : int</span>
<span class="sd">        Order of the B-spline.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    coeffs_pp : ndarray, shape (K, P, D)</span>
<span class="sd">        Coefficients of the piecewise polynomial where `K` is the order</span>
<span class="sd">        (``order``), `P` is the number of pieces and `D` is the dimension.</span>
<span class="sd">    breaks : ndarray, shape (P+1,)</span>
<span class="sd">        Break points of the piecewise polynomial.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">degree</span> <span class="o">=</span> <span class="n">order</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">breaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">knots</span><span class="p">)</span>
    <span class="n">pieces</span> <span class="o">=</span> <span class="n">breaks</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">dim</span> <span class="o">=</span> <span class="n">coeffs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">coeffs_pp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">order</span><span class="p">,</span> <span class="n">pieces</span><span class="p">,</span> <span class="n">dim</span><span class="p">))</span>

    <span class="c1"># have to do it manually for each dimension</span>
    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>

        <span class="n">bs</span> <span class="o">=</span> <span class="n">BSpline</span><span class="p">(</span><span class="n">knots</span><span class="p">,</span> <span class="n">coeffs</span><span class="p">[:,</span> <span class="n">d</span><span class="p">],</span> <span class="n">degree</span><span class="p">)</span>
        <span class="n">pp</span> <span class="o">=</span> <span class="n">PPoly</span><span class="o">.</span><span class="n">from_spline</span><span class="p">(</span><span class="n">bs</span><span class="p">,</span> <span class="n">extrapolate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># remove endpoint multiplicities</span>
        <span class="n">coeffs_pp</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">c</span><span class="p">[:,</span> <span class="n">degree</span><span class="p">:(</span><span class="n">degree</span><span class="o">+</span><span class="n">pieces</span><span class="p">)]</span>

    <span class="k">return</span> <span class="n">coeffs_pp</span><span class="p">,</span> <span class="n">breaks</span></div>


<div class="viewcode-block" id="synth_from_pp"><a class="viewcode-back" href="../../functions/chaosmagpy.model_utils.synth_from_pp.html#chaosmagpy.model_utils.synth_from_pp">[docs]</a><span class="k">def</span> <span class="nf">synth_from_pp</span><span class="p">(</span><span class="n">breaks</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">coeffs</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
                  <span class="n">nmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">deriv</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute radial, colatitude and azimuthal field components from the magnetic</span>
<span class="sd">    potential in terms of a spherical harmonic expansion in form of a</span>
<span class="sd">    piecewise polynomial.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    breaks : ndarray, shape (m+1,)</span>
<span class="sd">        1-D array, containing `m+1` break points (without endpoint repeats) for</span>
<span class="sd">        `m` intervals.</span>
<span class="sd">    order : int, positive</span>
<span class="sd">        Order `k` of piecewise polynomials (4 = cubic).</span>
<span class="sd">    coeffs : ndarray, shape (k, m, nmax*(nmax+2))</span>
<span class="sd">        Coefficients of the piecewise polynomials, where `m` is the number of</span>
<span class="sd">        polynomial pieces. The trailing dimension is equal to the number of</span>
<span class="sd">        expansion coefficients for each interval.</span>
<span class="sd">    time : ndarray, shape (...)</span>
<span class="sd">        Array containing the time in days.</span>
<span class="sd">    radius : ndarray, shape (...) or float</span>
<span class="sd">        Array containing the radius in kilometers.</span>
<span class="sd">    theta : ndarray, shape (...) or float</span>
<span class="sd">        Array containing the colatitude in degrees</span>
<span class="sd">        :math:`[0^\\circ,180^\\circ]`.</span>
<span class="sd">    phi : ndarray, shape (...) or float</span>
<span class="sd">        Array containing the longitude in degrees.</span>
<span class="sd">    nmax : int, positive, optional</span>
<span class="sd">        Maximum degree harmonic expansion (default is given by ``coeffs``,</span>
<span class="sd">        but can also be smaller, if specified).</span>
<span class="sd">    source : {&#39;internal&#39;, &#39;external&#39;}, optional</span>
<span class="sd">        Magnetic field source (default is an internal source).</span>
<span class="sd">    deriv : int, positive, optional</span>
<span class="sd">        Derivative to be taken (default is 0).</span>
<span class="sd">    grid : bool, optional</span>
<span class="sd">        If ``True``, field components are computed on a regular grid. Arrays</span>
<span class="sd">        ``theta`` and ``phi`` must have one dimension less than the output grid</span>
<span class="sd">        since the grid will be created as their outer product.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    B_radius, B_theta, B_phi : ndarray, shape (...)</span>
<span class="sd">        Radial, colatitude and azimuthal field components.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    synth_values</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># handle optional argument: nmax</span>
    <span class="n">nmax_coeffs</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">coeffs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># degree for coeffs</span>
    <span class="k">if</span> <span class="n">nmax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nmax</span> <span class="o">=</span> <span class="n">nmax_coeffs</span>
    <span class="k">elif</span> <span class="n">nmax</span> <span class="o">&gt;</span> <span class="n">nmax_coeffs</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Supplied nmax = </span><span class="si">{0}</span><span class="s1"> is incompatible with number of &#39;</span>
                      <span class="s1">&#39;model coefficients. Using nmax = </span><span class="si">{1}</span><span class="s1"> instead.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">nmax</span><span class="p">,</span> <span class="n">nmax_coeffs</span><span class="p">))</span>
        <span class="n">nmax</span> <span class="o">=</span> <span class="n">nmax_coeffs</span>

    <span class="c1"># handle optional argument: source</span>
    <span class="n">source</span> <span class="o">=</span> <span class="s1">&#39;internal&#39;</span> <span class="k">if</span> <span class="n">source</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">source</span>

    <span class="c1"># compute SH coefficients from pp-form and take derivatives if needed</span>
    <span class="n">deriv</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">deriv</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">deriv</span>

    <span class="c1"># set grid option to false</span>
    <span class="n">grid</span> <span class="o">=</span> <span class="kc">False</span> <span class="k">if</span> <span class="n">grid</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">grid</span>

    <span class="n">PP</span> <span class="o">=</span> <span class="n">PPoly</span><span class="o">.</span><span class="n">construct_fast</span><span class="p">(</span><span class="n">coeffs</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="n">nmax</span><span class="o">*</span><span class="p">(</span><span class="n">nmax</span><span class="o">+</span><span class="mi">2</span><span class="p">)],</span> <span class="n">breaks</span><span class="p">,</span>
                              <span class="n">extrapolate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">PP</span> <span class="o">=</span> <span class="n">PP</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="n">nu</span><span class="o">=</span><span class="n">deriv</span><span class="p">)</span>
    <span class="n">gauss_coeffs</span> <span class="o">=</span> <span class="n">PP</span><span class="p">(</span><span class="n">time</span><span class="p">)</span> <span class="o">*</span> <span class="mf">365.25</span><span class="o">**</span><span class="n">deriv</span>

    <span class="n">B_radius</span><span class="p">,</span> <span class="n">B_theta</span><span class="p">,</span> <span class="n">B_phi</span> <span class="o">=</span> <span class="n">synth_values</span><span class="p">(</span>
        <span class="n">gauss_coeffs</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">nmax</span><span class="o">=</span><span class="n">nmax</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="n">source</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="n">grid</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">B_radius</span><span class="p">,</span> <span class="n">B_theta</span><span class="p">,</span> <span class="n">B_phi</span></div>


<div class="viewcode-block" id="synth_values"><a class="viewcode-back" href="../../functions/chaosmagpy.model_utils.synth_values.html#chaosmagpy.model_utils.synth_values">[docs]</a><span class="k">def</span> <span class="nf">synth_values</span><span class="p">(</span><span class="n">coeffs</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">nmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">mmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes radial, colatitude and azimuthal field components from the</span>
<span class="sd">    magnetic potential field in terms of spherical harmonic coefficients.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    coeffs : ndarray, shape (..., M)</span>
<span class="sd">        Coefficients of the spherical harmonic expansion. The last dimension is</span>
<span class="sd">        equal to the number of coefficients.</span>
<span class="sd">    radius : float or ndarray, shape (...)</span>
<span class="sd">        Array containing the radius in kilometers.</span>
<span class="sd">    theta : float or ndarray, shape (...)</span>
<span class="sd">        Array containing the colatitude in degrees</span>
<span class="sd">        :math:`[0^\\circ,180^\\circ]`.</span>
<span class="sd">    phi : float or ndarray, shape (...)</span>
<span class="sd">        Array containing the longitude in degrees.</span>
<span class="sd">    nmax : int, positive, optional</span>
<span class="sd">        Maximum degree up to which expansion is to be used (default is given by</span>
<span class="sd">        the last dimension of ``coeffs``, that is, ``M = nmax(nmax+2)``). This</span>
<span class="sd">        value can also be smaller if only coefficients at low degree should</span>
<span class="sd">        contribute.</span>
<span class="sd">    nmin : int, positive, optional</span>
<span class="sd">        Minimum degree of the expansion (defaults to 1). This value must</span>
<span class="sd">        correspond to the minimum degree of the coefficients and cannot be</span>
<span class="sd">        larger.</span>
<span class="sd">    mmax : int, positive, optional</span>
<span class="sd">        Maximum order of the spherical harmonic expansion (defaults to</span>
<span class="sd">        ``nmax``). This value can also be smaller. For example, if only the</span>
<span class="sd">        zonal part of the expansion should be used, set ``mmax = 0``.</span>
<span class="sd">    source : {&#39;internal&#39;, &#39;external&#39;}, optional</span>
<span class="sd">        Magnetic field source (default is an internal source).</span>
<span class="sd">    grid : bool, optional</span>
<span class="sd">        If ``True``, field components are computed on a regular grid. Arrays</span>
<span class="sd">        ``theta`` and ``phi`` must have one dimension less than the output grid</span>
<span class="sd">        since the grid will be created as their outer product (defaults to</span>
<span class="sd">        ``False``).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    B_radius, B_theta, B_phi : ndarray, shape (...)</span>
<span class="sd">        Radial, colatitude and azimuthal field components.</span>

<span class="sd">    Warnings</span>
<span class="sd">    --------</span>
<span class="sd">    The function can also evaluate the field components at the geographic</span>
<span class="sd">    poles, i.e. where ``theta == 0.`` or ``theta == 180.``. However, users</span>
<span class="sd">    should be careful when doing this because the vector basis for spherical</span>
<span class="sd">    geocentric coordinates,</span>
<span class="sd">    :math:`{{\\mathbf{e}_r, \\mathbf{e}_\\theta, \\mathbf{e}_\\phi}}`,</span>
<span class="sd">    depends on longitude, which is not well defined at the poles. That is,</span>
<span class="sd">    at the poles, any value for the longitude maps to the same location in</span>
<span class="sd">    euclidean coordinates but gives a different vector basis in spherical</span>
<span class="sd">    geocentric coordinates. Nonetheless, by choosing a specific value for the</span>
<span class="sd">    longitude at the poles, users can define the vector basis, which then</span>
<span class="sd">    establishes the meaning of the spherical geocentric components returned by</span>
<span class="sd">    this function. The vector basis for the horizontal components is defined as</span>

<span class="sd">    .. math::</span>

<span class="sd">        \\mathbf{e}_\\theta &amp;= \\cos\\theta\\cos\\phi\\mathbf{e}_x -</span>
<span class="sd">            \\cos\\theta\\sin\\phi\\mathbf{e}_y - \\sin\\theta\\mathbf{e}_z\\\\</span>
<span class="sd">        \\mathbf{e}_\\phi &amp;= -\\sin\\phi\\mathbf{e}_x +</span>
<span class="sd">            \\cos\\phi\\mathbf{e}_y</span>

<span class="sd">    Hence, at the geographic north pole as given by ``theta = 0.`` and</span>
<span class="sd">    ``phi = 0.`` (chosen by the user), the returned component ``B_theta``</span>
<span class="sd">    will be along the direction :math:`\\mathbf{e}_\\theta = \\mathbf{e}_x` and</span>
<span class="sd">    ``B_phi`` along :math:`\\mathbf{e}_\\phi = \\mathbf{e}_y`. However,</span>
<span class="sd">    if ``phi = 180.`` is chosen, ``B_theta``</span>
<span class="sd">    will be along :math:`\\mathbf{e}_\\theta = -\\mathbf{e}_x` and ``B_phi``</span>
<span class="sd">    along :math:`\\mathbf{e}_\\phi = -\\mathbf{e}_y`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The function can work with different grid shapes, but the inputs have to</span>
<span class="sd">    satisfy NumPy&#39;s `broadcasting rules \\</span>
<span class="sd">    &lt;https://docs.scipy.org/doc/numpy-1.15.0/user/basics.broadcasting.html&gt;`_</span>
<span class="sd">    (``grid=False``, default). This also applies to the dimension of the</span>
<span class="sd">    coefficients ``coeffs`` excluding the last dimension.</span>

<span class="sd">    The optional parameter ``grid`` is for convenience. If set to ``True``,</span>
<span class="sd">    a singleton dimension is appended (prepended) to ``theta`` (``phi``)</span>
<span class="sd">    for broadcasting to a regular grid. The other inputs ``radius`` and</span>
<span class="sd">    ``coeffs`` must then be broadcastable as before but now with the resulting</span>
<span class="sd">    regular grid.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The most straight forward computation uses a fully specified grid. For</span>
<span class="sd">    example, compute the magnetic field at :math:`N=50` grid points on the</span>
<span class="sd">    surface.</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">      import chaosmagpy.model_utils as cpm</span>
<span class="sd">      import numpy as np</span>

<span class="sd">      N = 50</span>
<span class="sd">      coeffs = np.ones((3,))  # degree 1 coefficients for all points</span>
<span class="sd">      radius = 6371.2 * np.ones((N,))  # radius of 50 points in km</span>
<span class="sd">      phi = np.linspace(-180., 180., num=N)  # azimuth of 50 points in deg.</span>
<span class="sd">      theta = np.linspace(0., 180., num=N)  # colatitude of 50 points in deg.</span>

<span class="sd">      B = cpm.synth_values(coeffs, radius, theta, phi)</span>
<span class="sd">      print([B[num].shape for num in range(3)])  # output shape (N,)</span>

<span class="sd">    Instead of `N` points, compute the field on a regular</span>
<span class="sd">    :math:`N\\times N`-grid in azimuth and colatitude (slow).</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">      radius_grid = 6371.2 * np.ones((N, N))</span>
<span class="sd">      phi_grid, theta_grid = np.meshgrid(phi, theta)  # grid of shape (N, N)</span>

<span class="sd">      B = cpm.synth_values(coeffs, radius_grid, theta_grid, phi_grid)</span>
<span class="sd">      print([B[num].shape for num in range(3)])  # output shape (N, N)</span>

<span class="sd">    But this is slow since some computations on the grid are repeatedly done.</span>
<span class="sd">    The preferred method is to use NumPy&#39;s broadcasting rules (fast).</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">      radius_grid = 6371.2  # float, () or (1,)-shaped array broadcasted to NxN</span>
<span class="sd">      theta_grid = theta[:, None]  # append singleton: (N, 1)</span>
<span class="sd">      phi_grid = phi[None, :]  # prepend singleton: (1, N)</span>

<span class="sd">      B = cpm.synth_values(coeffs, radius_grid, theta_grid, phi_grid)</span>
<span class="sd">      print([B[num].shape for num in range(3)])  # output shape (N, N)</span>

<span class="sd">    For convenience, you can do the same by using ``grid=True`` option, which</span>
<span class="sd">    appends a singleton dimension to ``theta`` and inserts a singleton</span>
<span class="sd">    dimension at the second to last position in the shape of ``phi``.</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">      B = cpm.synth_values(coeffs, radius_grid, theta, phi, grid=True)</span>
<span class="sd">      print([B[num].shape for num in range(3)])  # output shape (N, N)</span>

<span class="sd">    Remember that ``grid=False`` (default) will result in</span>
<span class="sd">    (N,)-shaped outputs as in the first example.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ensure ndarray inputs</span>
    <span class="n">coeffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">coeffs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">radius</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">radius</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span> <span class="o">/</span> <span class="n">basicConfig</span><span class="p">[</span><span class="s1">&#39;params.r_surf&#39;</span><span class="p">]</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

    <span class="n">theta_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">theta_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">theta_min</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">theta_max</span> <span class="o">&gt;=</span> <span class="mf">180.0</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">theta_min</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">theta_max</span> <span class="o">==</span> <span class="mf">180.0</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Supplied coordinates include the poles.&#39;</span><span class="p">)</span>
            <span class="n">poles</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Colatitude outside bounds [0, 180].&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">poles</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">nmin</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">nmin</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">nmin</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">nmin</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;The value of &quot;nmin&quot; must be greater than zero.&#39;</span>

    <span class="n">dim</span> <span class="o">=</span> <span class="n">coeffs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># handle nmax and mmax</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nmax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">mmax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">nmax</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dim</span> <span class="o">+</span> <span class="n">nmin</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">mmax</span> <span class="o">=</span> <span class="n">nmax</span>

    <span class="k">elif</span> <span class="n">mmax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># but nmax given</span>
        <span class="n">mmax</span> <span class="o">=</span> <span class="n">nmax</span>

    <span class="k">elif</span> <span class="n">nmax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># but mmax given</span>

        <span class="k">if</span> <span class="n">mmax</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">nmin</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">nmax</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">dim</span> <span class="o">-</span> <span class="n">mmax</span><span class="o">*</span><span class="p">(</span><span class="n">mmax</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">nmin</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">mmax</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">mmax</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">nmax</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dim</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">mmax</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">nmin</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">nmax</span> <span class="o">&lt;</span> <span class="n">nmin</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Nothing to compute: nmax (</span><span class="si">{</span><span class="n">nmax</span><span class="si">}</span><span class="s1">) &lt; nmin (</span><span class="si">{</span><span class="n">nmin</span><span class="si">}</span><span class="s1">).&#39;</span><span class="p">)</span>

    <span class="c1"># handle optional argument: source</span>
    <span class="k">if</span> <span class="n">source</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">source</span> <span class="o">=</span> <span class="s1">&#39;internal&#39;</span>

    <span class="c1"># handle grid option</span>
    <span class="n">grid</span> <span class="o">=</span> <span class="kc">False</span> <span class="k">if</span> <span class="n">grid</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">grid</span>

    <span class="c1"># manually broadcast input grid on surface</span>
    <span class="k">if</span> <span class="n">grid</span><span class="p">:</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># append singleton dimension</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># insert singleton before last</span>

    <span class="c1"># get shape of broadcasted result</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast</span><span class="p">(</span>
            <span class="n">radius</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">coeffs</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Cannot broadcast grid shapes (excl. last dimension of coeffs):&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;radius: </span><span class="si">{</span><span class="n">radius</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;theta:  </span><span class="si">{</span><span class="n">theta</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;phi:    </span><span class="si">{</span><span class="n">phi</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;coeffs: </span><span class="si">{</span><span class="n">coeffs</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">raise</span>

    <span class="n">grid_shape</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span>

    <span class="c1"># initialize radial dependence given the source</span>
    <span class="k">if</span> <span class="n">source</span> <span class="o">==</span> <span class="s1">&#39;internal&#39;</span><span class="p">:</span>
        <span class="n">r_n</span> <span class="o">=</span> <span class="n">radius</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">nmin</span><span class="o">+</span><span class="mi">2</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">source</span> <span class="o">==</span> <span class="s1">&#39;external&#39;</span><span class="p">:</span>
        <span class="n">r_n</span> <span class="o">=</span> <span class="n">radius</span><span class="o">**</span><span class="p">(</span><span class="n">nmin</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Source must be either &#39;internal&#39; or &#39;external&#39;.&quot;</span><span class="p">)</span>

    <span class="c1"># compute associated Legendre polynomials as (n, m, theta-points)-array</span>
    <span class="n">Pnm</span> <span class="o">=</span> <span class="n">legendre_poly</span><span class="p">(</span><span class="n">nmax</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>

    <span class="c1"># save sinth for fast access</span>
    <span class="n">sinth</span> <span class="o">=</span> <span class="n">Pnm</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

    <span class="c1"># find the poles</span>
    <span class="k">if</span> <span class="n">poles</span><span class="p">:</span>
        <span class="n">where_poles</span> <span class="o">=</span> <span class="p">(</span><span class="n">theta</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">theta</span> <span class="o">==</span> <span class="mf">180.</span><span class="p">)</span>

    <span class="c1"># convert phi to radians</span>
    <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>

    <span class="c1"># allocate arrays in memory</span>
    <span class="n">B_radius</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">grid_shape</span><span class="p">)</span>
    <span class="n">B_theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">grid_shape</span><span class="p">)</span>
    <span class="n">B_phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">grid_shape</span><span class="p">)</span>

    <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nmin</span><span class="p">,</span> <span class="n">nmax</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">source</span> <span class="o">==</span> <span class="s1">&#39;internal&#39;</span><span class="p">:</span>
            <span class="n">B_radius</span> <span class="o">+=</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">Pnm</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">r_n</span> <span class="o">*</span> <span class="n">coeffs</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">num</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">B_radius</span> <span class="o">+=</span> <span class="o">-</span><span class="n">n</span> <span class="o">*</span> <span class="n">Pnm</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">r_n</span> <span class="o">*</span> <span class="n">coeffs</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">num</span><span class="p">]</span>

        <span class="n">B_theta</span> <span class="o">+=</span> <span class="o">-</span><span class="n">Pnm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">r_n</span> <span class="o">*</span> <span class="n">coeffs</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">num</span><span class="p">]</span>

        <span class="n">num</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">mmax</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>

            <span class="n">cmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">m</span><span class="o">*</span><span class="n">phi</span><span class="p">)</span>
            <span class="n">smp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">m</span><span class="o">*</span><span class="n">phi</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">source</span> <span class="o">==</span> <span class="s1">&#39;internal&#39;</span><span class="p">:</span>
                <span class="n">B_radius</span> <span class="o">+=</span> <span class="p">((</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">Pnm</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span> <span class="o">*</span> <span class="n">r_n</span>
                             <span class="o">*</span> <span class="p">(</span><span class="n">coeffs</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">num</span><span class="p">]</span> <span class="o">*</span> <span class="n">cmp</span>
                                <span class="o">+</span> <span class="n">coeffs</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">num</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">smp</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">B_radius</span> <span class="o">+=</span> <span class="o">-</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">Pnm</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span> <span class="o">*</span> <span class="n">r_n</span>
                              <span class="o">*</span> <span class="p">(</span><span class="n">coeffs</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">num</span><span class="p">]</span> <span class="o">*</span> <span class="n">cmp</span>
                                 <span class="o">+</span> <span class="n">coeffs</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">num</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">smp</span><span class="p">))</span>

            <span class="n">B_theta</span> <span class="o">+=</span> <span class="p">(</span><span class="o">-</span><span class="n">Pnm</span><span class="p">[</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">r_n</span>
                        <span class="o">*</span> <span class="p">(</span><span class="n">coeffs</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">num</span><span class="p">]</span> <span class="o">*</span> <span class="n">cmp</span>
                           <span class="o">+</span> <span class="n">coeffs</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">num</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">smp</span><span class="p">))</span>

            <span class="c1"># need special treatment at the poles because Pnm/sinth = 0/0 for</span>
            <span class="c1"># theta in {0., 180.},</span>
            <span class="c1"># use L&#39;Hopital&#39;s rule to take the limit:</span>
            <span class="c1"># lim Pnm/sinth = k*dPnm | theta in {0., 180}</span>
            <span class="c1"># (evaluated at poles, where k=1 for theta=0 and k=-1 for</span>
            <span class="c1"># theta=180.); k = costh = P[1, 0] at poles for convenience</span>
            <span class="k">if</span> <span class="n">poles</span><span class="p">:</span>
                <span class="n">div_Pnm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">where_poles</span><span class="p">,</span> <span class="n">Pnm</span><span class="p">[</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">Pnm</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">])</span>
                <span class="n">div_Pnm</span><span class="p">[</span><span class="n">where_poles</span><span class="p">]</span> <span class="o">*=</span> <span class="n">Pnm</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">][</span><span class="n">where_poles</span><span class="p">]</span>
                <span class="n">div_Pnm</span><span class="p">[</span><span class="o">~</span><span class="n">where_poles</span><span class="p">]</span> <span class="o">/=</span> <span class="n">sinth</span><span class="p">[</span><span class="o">~</span><span class="n">where_poles</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">div_Pnm</span> <span class="o">=</span> <span class="n">Pnm</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span> <span class="o">/</span> <span class="n">sinth</span>

            <span class="n">B_phi</span> <span class="o">+=</span> <span class="p">(</span><span class="n">m</span> <span class="o">*</span> <span class="n">div_Pnm</span> <span class="o">*</span> <span class="n">r_n</span>
                      <span class="o">*</span> <span class="p">(</span><span class="n">coeffs</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">num</span><span class="p">]</span> <span class="o">*</span> <span class="n">smp</span>
                         <span class="o">-</span> <span class="n">coeffs</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">num</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">cmp</span><span class="p">))</span>

            <span class="n">num</span> <span class="o">+=</span> <span class="mi">2</span>

        <span class="k">if</span> <span class="n">source</span> <span class="o">==</span> <span class="s1">&#39;internal&#39;</span><span class="p">:</span>
            <span class="n">r_n</span> <span class="o">=</span> <span class="n">r_n</span> <span class="o">/</span> <span class="n">radius</span>  <span class="c1"># equivalent to r_n = radius**(-(n+2))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">r_n</span> <span class="o">=</span> <span class="n">r_n</span> <span class="o">*</span> <span class="n">radius</span>  <span class="c1"># equivalent to r_n = radius**(n-1)</span>

    <span class="k">return</span> <span class="n">B_radius</span><span class="p">,</span> <span class="n">B_theta</span><span class="p">,</span> <span class="n">B_phi</span></div>


<div class="viewcode-block" id="design_gauss"><a class="viewcode-back" href="../../functions/chaosmagpy.model_utils.design_gauss.html#chaosmagpy.model_utils.design_gauss">[docs]</a><span class="k">def</span> <span class="nf">design_gauss</span><span class="p">(</span><span class="n">radius</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">nmax</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">nmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">source</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes matrices to connect the radial, colatitude and azimuthal field</span>
<span class="sd">    components to the magnetic potential field in terms of spherical harmonic</span>
<span class="sd">    coefficients (Schmidt quasi-normalized).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    radius : ndarray, shape (...)</span>
<span class="sd">        Array containing the radius in kilometers.</span>
<span class="sd">    theta : ndarray, shape (...)</span>
<span class="sd">        Array containing the colatitude in degrees</span>
<span class="sd">        :math:`[0^\\circ,180^\\circ]`.</span>
<span class="sd">    phi : ndarray, shape (...)</span>
<span class="sd">        Array containing the longitude in degrees.</span>
<span class="sd">    nmax : int, positive</span>
<span class="sd">        Maximum degree of the sphercial harmonic expansion.</span>
<span class="sd">    nmin : int, positive, optional</span>
<span class="sd">        Minimum degree of the sphercial harmonic expansion (defaults to 1).</span>
<span class="sd">    mmax : int, positive, optional</span>
<span class="sd">        Maximum order of the spherical harmonic expansion (defaults to</span>
<span class="sd">        ``nmax``). For ``mmax = 0``, for example, only the zonal terms are</span>
<span class="sd">        returned.</span>
<span class="sd">    source : {&#39;internal&#39;, &#39;external&#39;}, optional</span>
<span class="sd">        Magnetic field source (default is an internal source).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A_radius, A_theta, A_phi : ndarray, shape (..., M)</span>
<span class="sd">        Matrices for radial, colatitude and azimuthal field components. The</span>
<span class="sd">        second dimension ``M`` varies depending on ``nmax``, ``nmin`` and</span>
<span class="sd">        ``mmax``.</span>

<span class="sd">    Warnings</span>
<span class="sd">    --------</span>
<span class="sd">    The function can also return the design matrix for the field components at</span>
<span class="sd">    the geographic poles, i.e. where ``theta == 0.`` or ``theta == 180.``.</span>
<span class="sd">    However, users should be careful when doing this because the vector basis</span>
<span class="sd">    for spherical geocentric coordinates,</span>
<span class="sd">    :math:`{{\\mathbf{e}_r, \\mathbf{e}_\\theta, \\mathbf{e}_\\phi}}`,</span>
<span class="sd">    depends on longitude, which is not well defined at the poles. That is,</span>
<span class="sd">    at the poles, any value for the longitude maps to the same location in</span>
<span class="sd">    euclidean coordinates but gives a different vector basis in spherical</span>
<span class="sd">    geocentric coordinates. Nonetheless, by choosing a specific value for the</span>
<span class="sd">    longitude at the poles, users can define the vector basis, which then</span>
<span class="sd">    establishes the meaning of the spherical geocentric components. The vector</span>
<span class="sd">    basis for the horizontal components is defined as</span>

<span class="sd">    .. math::</span>

<span class="sd">        \\mathbf{e}_\\theta &amp;= \\cos\\theta\\cos\\phi\\mathbf{e}_x -</span>
<span class="sd">            \\cos\\theta\\sin\\phi\\mathbf{e}_y - \\sin\\theta\\mathbf{e}_z\\\\</span>
<span class="sd">        \\mathbf{e}_\\phi &amp;= -\\sin\\phi\\mathbf{e}_x +</span>
<span class="sd">            \\cos\\phi\\mathbf{e}_y</span>

<span class="sd">    Hence, at the geographic north pole as given by ``theta = 0.`` and</span>
<span class="sd">    ``phi = 0.`` (chosen by the user), the returned design matrix ``A_theta``</span>
<span class="sd">    will be for components along the direction</span>
<span class="sd">    :math:`\\mathbf{e}_\\theta = \\mathbf{e}_x` and ``A_phi`` for components</span>
<span class="sd">    along :math:`\\mathbf{e}_\\phi = \\mathbf{e}_y`. However,</span>
<span class="sd">    if ``phi = 180.`` is chosen, ``A_theta`` will be for components along</span>
<span class="sd">    :math:`\\mathbf{e}_\\theta = -\\mathbf{e}_x` and ``A_phi``</span>
<span class="sd">    along :math:`\\mathbf{e}_\\phi = -\\mathbf{e}_y`.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ensure ndarray inputs</span>
    <span class="n">radius</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">radius</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span> <span class="o">/</span> <span class="n">basicConfig</span><span class="p">[</span><span class="s1">&#39;params.r_surf&#39;</span><span class="p">]</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

    <span class="c1"># get shape of broadcasted result</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast</span><span class="p">(</span><span class="n">radius</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">)</span>

    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Cannot broadcast grid shapes:&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;radius: </span><span class="si">{</span><span class="n">radius</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;theta:  </span><span class="si">{</span><span class="n">theta</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;phi:    </span><span class="si">{</span><span class="n">phi</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">raise</span>

    <span class="n">shape</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span>

    <span class="n">theta_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">theta_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

    <span class="c1"># check if poles are included</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">theta_min</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">theta_max</span> <span class="o">&gt;=</span> <span class="mf">180.0</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">theta_min</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">theta_max</span> <span class="o">==</span> <span class="mf">180.0</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Supplied coordinates include the poles.&#39;</span><span class="p">)</span>
            <span class="n">poles</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Colatitude outside bounds [0, 180].&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">poles</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># set internal source as default</span>
    <span class="k">if</span> <span class="n">source</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">source</span> <span class="o">=</span> <span class="s1">&#39;internal&#39;</span>

    <span class="k">assert</span> <span class="n">nmax</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;&quot;nmax&quot; must be greater than zero.&#39;</span>

    <span class="n">nmin</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">nmin</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">nmin</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">nmin</span> <span class="o">&lt;=</span> <span class="n">nmax</span><span class="p">,</span> <span class="s1">&#39;&quot;nmin&quot; must be smaller than &quot;nmax&quot;.&#39;</span>
    <span class="k">assert</span> <span class="n">nmin</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;&quot;nmin&quot; must be greater than zero.&#39;</span>

    <span class="n">mmax</span> <span class="o">=</span> <span class="n">nmax</span> <span class="k">if</span> <span class="n">mmax</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">mmax</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">mmax</span> <span class="o">&lt;=</span> <span class="n">nmax</span><span class="p">,</span> <span class="s1">&#39;&quot;mmax&quot; must be smaller than &quot;nmax&quot;.&#39;</span>
    <span class="k">assert</span> <span class="n">mmax</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;&quot;mmax&quot; must be greater than or equal to zero.&#39;</span>

    <span class="c1"># initialize radial dependence given the source</span>
    <span class="k">if</span> <span class="n">source</span> <span class="o">==</span> <span class="s1">&#39;internal&#39;</span><span class="p">:</span>
        <span class="n">r_n</span> <span class="o">=</span> <span class="n">radius</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">nmin</span><span class="o">+</span><span class="mi">2</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">source</span> <span class="o">==</span> <span class="s1">&#39;external&#39;</span><span class="p">:</span>
        <span class="n">r_n</span> <span class="o">=</span> <span class="n">radius</span><span class="o">**</span><span class="p">(</span><span class="n">nmin</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Source must be either &#39;internal&#39; or &#39;external&#39;.&quot;</span><span class="p">)</span>

    <span class="c1"># compute associated Legendre polynomials as (n, m, theta-points)-array</span>
    <span class="n">Pnm</span> <span class="o">=</span> <span class="n">legendre_poly</span><span class="p">(</span><span class="n">nmax</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>
    <span class="n">sinth</span> <span class="o">=</span> <span class="n">Pnm</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

    <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>

    <span class="c1"># find the poles</span>
    <span class="k">if</span> <span class="n">poles</span><span class="p">:</span>
        <span class="n">where_poles</span> <span class="o">=</span> <span class="p">(</span><span class="n">theta</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">theta</span> <span class="o">==</span> <span class="mf">180.</span><span class="p">)</span>

    <span class="c1"># compute the number of dimensions based on nmax, nmin, mmax</span>
    <span class="k">if</span> <span class="n">mmax</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">nmin</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">mmax</span><span class="o">*</span><span class="p">(</span><span class="n">mmax</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">nmax</span><span class="o">-</span><span class="n">mmax</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">mmax</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">nmin</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">nmax</span><span class="o">-</span><span class="n">nmin</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">mmax</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>

    <span class="c1"># allocate A_radius, A_theta, A_phi in memeory</span>
    <span class="n">A_radius</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span> <span class="o">+</span> <span class="p">(</span><span class="n">dim</span><span class="p">,))</span>
    <span class="n">A_theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span> <span class="o">+</span> <span class="p">(</span><span class="n">dim</span><span class="p">,))</span>
    <span class="n">A_phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span> <span class="o">+</span> <span class="p">(</span><span class="n">dim</span><span class="p">,))</span>

    <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nmin</span><span class="p">,</span> <span class="n">nmax</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">source</span> <span class="o">==</span> <span class="s1">&#39;internal&#39;</span><span class="p">:</span>
            <span class="n">A_radius</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">num</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">Pnm</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">r_n</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">A_radius</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">num</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">n</span> <span class="o">*</span> <span class="n">Pnm</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">r_n</span>

        <span class="n">A_theta</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">num</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">Pnm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">r_n</span>

        <span class="n">num</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">mmax</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>

            <span class="n">cmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">m</span><span class="o">*</span><span class="n">phi</span><span class="p">)</span>
            <span class="n">smp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">m</span><span class="o">*</span><span class="n">phi</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">source</span> <span class="o">==</span> <span class="s1">&#39;internal&#39;</span><span class="p">:</span>
                <span class="n">A_radius</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">num</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">Pnm</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span> <span class="o">*</span> <span class="n">r_n</span> <span class="o">*</span> <span class="n">cmp</span>
                <span class="n">A_radius</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">num</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">Pnm</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span> <span class="o">*</span> <span class="n">r_n</span> <span class="o">*</span> <span class="n">smp</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">A_radius</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">num</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">n</span> <span class="o">*</span> <span class="n">Pnm</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span> <span class="o">*</span> <span class="n">r_n</span> <span class="o">*</span> <span class="n">cmp</span>
                <span class="n">A_radius</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">num</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">n</span> <span class="o">*</span> <span class="n">Pnm</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span> <span class="o">*</span> <span class="n">r_n</span> <span class="o">*</span> <span class="n">smp</span>

            <span class="n">A_theta</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">num</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">Pnm</span><span class="p">[</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">r_n</span> <span class="o">*</span> <span class="n">cmp</span>
            <span class="n">A_theta</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">num</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">Pnm</span><span class="p">[</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">r_n</span> <span class="o">*</span> <span class="n">smp</span>

            <span class="c1"># need special treatment at the poles because Pnm/sinth = 0/0 for</span>
            <span class="c1"># theta in {0., 180.},</span>
            <span class="c1"># use L&#39;Hopital&#39;s rule to take the limit:</span>
            <span class="c1"># lim Pnm/sinth = k*dPnm | theta in {0., 180}</span>
            <span class="c1"># (evaluated at poles, where k=1 for theta=0 and k=-1 for</span>
            <span class="c1"># theta=180.); k = costh = P[1, 0] at poles for convenience</span>
            <span class="k">if</span> <span class="n">poles</span><span class="p">:</span>
                <span class="n">div_Pnm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">where_poles</span><span class="p">,</span> <span class="n">Pnm</span><span class="p">[</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">Pnm</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">])</span>
                <span class="n">div_Pnm</span><span class="p">[</span><span class="n">where_poles</span><span class="p">]</span> <span class="o">*=</span> <span class="n">Pnm</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">][</span><span class="n">where_poles</span><span class="p">]</span>
                <span class="n">div_Pnm</span><span class="p">[</span><span class="o">~</span><span class="n">where_poles</span><span class="p">]</span> <span class="o">/=</span> <span class="n">sinth</span><span class="p">[</span><span class="o">~</span><span class="n">where_poles</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">div_Pnm</span> <span class="o">=</span> <span class="n">Pnm</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span> <span class="o">/</span> <span class="n">sinth</span>

            <span class="n">A_phi</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">num</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span> <span class="o">*</span> <span class="n">div_Pnm</span> <span class="o">*</span> <span class="n">r_n</span> <span class="o">*</span> <span class="n">smp</span>
            <span class="n">A_phi</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">num</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">m</span> <span class="o">*</span> <span class="n">div_Pnm</span> <span class="o">*</span> <span class="n">r_n</span> <span class="o">*</span> <span class="n">cmp</span>

            <span class="n">num</span> <span class="o">+=</span> <span class="mi">2</span>

        <span class="c1"># update radial dependence given the source</span>
        <span class="k">if</span> <span class="n">source</span> <span class="o">==</span> <span class="s1">&#39;internal&#39;</span><span class="p">:</span>
            <span class="n">r_n</span> <span class="o">=</span> <span class="n">r_n</span> <span class="o">/</span> <span class="n">radius</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">r_n</span> <span class="o">=</span> <span class="n">r_n</span> <span class="o">*</span> <span class="n">radius</span>

    <span class="k">return</span> <span class="n">A_radius</span><span class="p">,</span> <span class="n">A_theta</span><span class="p">,</span> <span class="n">A_phi</span></div>


<div class="viewcode-block" id="legendre_poly"><a class="viewcode-back" href="../../functions/chaosmagpy.model_utils.legendre_poly.html#chaosmagpy.model_utils.legendre_poly">[docs]</a><span class="k">def</span> <span class="nf">legendre_poly</span><span class="p">(</span><span class="n">nmax</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns associated Legendre polynomials :math:`P_n^m(\\cos\\theta)`</span>
<span class="sd">    (Schmidt quasi-normalized) and the derivative</span>
<span class="sd">    :math:`dP_n^m(\\cos\\theta)/d\\theta` evaluated at :math:`\\theta`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nmax : int, positive</span>
<span class="sd">        Maximum degree of the spherical expansion.</span>
<span class="sd">    theta : ndarray, shape (...)</span>
<span class="sd">        Colatitude in degrees :math:`[0^\\circ, 180^\\circ]`</span>
<span class="sd">        of arbitrary shape.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Pnm : ndarray, shape (n, m, ...)</span>
<span class="sd">          Evaluated values and derivatives, grid shape is appended as trailing</span>
<span class="sd">          dimensions. :math:`P_n^m(\\cos\\theta)` := ``Pnm[n, m, ...]`` and</span>
<span class="sd">          :math:`dP_n^m(\\cos\\theta)/d\\theta` := ``Pnm[m, n+1, ...]``</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    Based on Equations 26-29 and Table 2 in:</span>

<span class="sd">    Langel, R. A., &quot;Geomagnetism - The main field&quot;, Academic Press, 1987,</span>
<span class="sd">    chapter 4</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">costh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span>
    <span class="n">sinth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">costh</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="n">Pnm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nmax</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">nmax</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">costh</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">Pnm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>  <span class="c1"># is copied into trailing dimensions</span>
    <span class="n">Pnm</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sinth</span>  <span class="c1"># write theta into trailing dimenions via broadcasting</span>

    <span class="n">rootn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">nmax</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

    <span class="c1"># Recursion relations after Langel &quot;The Main Field&quot; (1987),</span>
    <span class="c1"># eq. (27) and Table 2 (p. 256)</span>
    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nmax</span><span class="p">):</span>
        <span class="n">Pnm_tmp</span> <span class="o">=</span> <span class="n">rootn</span><span class="p">[</span><span class="n">m</span><span class="o">+</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">Pnm</span><span class="p">[</span><span class="n">m</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span>
        <span class="n">Pnm</span><span class="p">[</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">costh</span> <span class="o">*</span> <span class="n">Pnm_tmp</span>

        <span class="k">if</span> <span class="n">m</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">Pnm</span><span class="p">[</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sinth</span><span class="o">*</span><span class="n">Pnm_tmp</span> <span class="o">/</span> <span class="n">rootn</span><span class="p">[</span><span class="n">m</span><span class="o">+</span><span class="n">m</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="n">nmax</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">n</span> <span class="o">-</span> <span class="n">m</span> <span class="o">*</span> <span class="n">m</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">Pnm</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">e</span> <span class="o">*</span> <span class="n">costh</span> <span class="o">*</span> <span class="n">Pnm</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span> <span class="o">-</span> <span class="n">rootn</span><span class="p">[</span><span class="n">d</span><span class="o">-</span><span class="n">e</span><span class="p">]</span> <span class="o">*</span> <span class="n">Pnm</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="n">m</span><span class="p">])</span>
                         <span class="o">/</span> <span class="n">rootn</span><span class="p">[</span><span class="n">d</span><span class="p">])</span>

    <span class="c1"># dP(n,m) = Pnm(m,n+1) is the derivative of P(n,m) vrt. theta</span>
    <span class="n">Pnm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">Pnm</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">Pnm</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">Pnm</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">nmax</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">Pnm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">n</span><span class="o">*</span><span class="n">n</span> <span class="o">+</span> <span class="n">n</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">Pnm</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">Pnm</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="n">n</span> <span class="o">+</span> <span class="n">n</span><span class="p">))</span> <span class="o">*</span> <span class="n">Pnm</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                       <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">n</span><span class="o">*</span><span class="n">n</span> <span class="o">+</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">))</span> <span class="o">*</span> <span class="n">Pnm</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="n">Pnm</span><span class="p">[</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">n</span> <span class="o">+</span> <span class="n">m</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">Pnm</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                           <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">n</span> <span class="o">+</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">m</span><span class="p">))</span> <span class="o">*</span> <span class="n">Pnm</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">]))</span>

        <span class="n">Pnm</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">Pnm</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="k">return</span> <span class="n">Pnm</span></div>


<div class="viewcode-block" id="power_spectrum"><a class="viewcode-back" href="../../functions/chaosmagpy.model_utils.power_spectrum.html#chaosmagpy.model_utils.power_spectrum">[docs]</a><span class="k">def</span> <span class="nf">power_spectrum</span><span class="p">(</span><span class="n">coeffs</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">nmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the spatial power spectrum.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    coeffs : ndarray, shape (..., N*(N+2))</span>
<span class="sd">        Spherical harmonic coefficients for degree `N`.</span>
<span class="sd">    radius : float, optional</span>
<span class="sd">        Radius in kilometers (defaults to mean Earth&#39;s surface radius).</span>
<span class="sd">        It has no effect for ``source=&#39;toroidal&#39;``.</span>
<span class="sd">    nmax : int, optional</span>
<span class="sd">        Maximum spherical degree (defaults to `N`).</span>
<span class="sd">    source : {&#39;internal&#39;, &#39;external&#39;, &#39;toroidal&#39;}</span>
<span class="sd">        Source of the field model (defaults to internal).</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Axis of ``coeffs`` along which to compute the spatial power spectrum</span>
<span class="sd">        (defaults to -1, last dimension of ``coeffs``).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    W_n : ndarray, shape (..., ``nmax``)</span>
<span class="sd">        Power spectrum for degrees up to degree ``nmax``</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The spatial power spectrum for a potential field is defined as</span>

<span class="sd">    .. math::</span>

<span class="sd">        W_n(r) &amp;= \\langle|\\mathbf{B}|^2\\rangle</span>
<span class="sd">             = \\frac{1}{4\\pi}\\iint_\\Omega |\\mathbf{B}|^2 \\mathrm{d}</span>
<span class="sd">               \\Omega \\\\</span>
<span class="sd">             &amp;= W_n^\\mathrm{i}(r) + W_n^\\mathrm{e}(r) + W_n^\\mathrm{T}</span>

<span class="sd">    where the internal :math:`W_n^\\mathrm{i}`, external</span>
<span class="sd">    :math:`W_n^\\mathrm{e}` and the non-potential toroidal</span>
<span class="sd">    :math:`W_n^\\mathrm{T}` spatial power spectra are</span>

<span class="sd">    .. math::</span>

<span class="sd">        W_n^\\mathrm{i}(r) &amp;= (n+1)\\left(\\frac{a}{r}\\right)^{2n+4}</span>
<span class="sd">                              \\sum_{m=0}^n [(g_n^m)^2 + (h_n^m)^2] \\\\</span>
<span class="sd">        W_n^\\mathrm{e}(r) &amp;= n\\left(\\frac{r}{a}\\right)^{2n-2}\\sum_{m=0}^n</span>
<span class="sd">                              [(q_n^m)^2 + (s_n^m)^2] \\\\</span>
<span class="sd">        W_n^\\mathrm{T}    &amp;= \\frac{n(n+1)}{2n+1}\\sum_{m=0}^n</span>
<span class="sd">                              [(T_n^{m,c})^2 + (T_n^{m,s})^2]</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    Sabaka, T. J.; Hulot, G. &amp; Olsen, N.,</span>
<span class="sd">    &quot;Mathematical properties relevant to geomagnetic field modeling&quot;,</span>
<span class="sd">    Handbook of geomathematics, Springer, 2010, 503-538</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">axis</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">radius</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">basicConfig</span><span class="p">[</span><span class="s1">&#39;params.r_surf&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">radius</span>

    <span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">coeffs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># maximum degree</span>

    <span class="k">if</span> <span class="n">nmax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nmax</span> <span class="o">=</span> <span class="n">N</span>
    <span class="k">elif</span> <span class="n">nmax</span> <span class="o">&gt;</span> <span class="n">N</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Incompatible maximum degree nmax = </span><span class="si">{</span><span class="n">nmax</span><span class="si">}</span><span class="s1">, &#39;</span>
              <span class="sa">f</span><span class="s1">&#39;setting nmax to </span><span class="si">{</span><span class="n">N</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
        <span class="n">nmax</span> <span class="o">=</span> <span class="n">N</span>

    <span class="n">source</span> <span class="o">=</span> <span class="s1">&#39;internal&#39;</span> <span class="k">if</span> <span class="n">source</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">source</span>

    <span class="k">if</span> <span class="n">source</span> <span class="o">==</span> <span class="s1">&#39;internal&#39;</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">factor</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">r</span><span class="o">**</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">4</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">source</span> <span class="o">==</span> <span class="s1">&#39;external&#39;</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">factor</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="n">r</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">source</span> <span class="o">==</span> <span class="s1">&#39;toroidal&#39;</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">factor</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">n</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;Unknown source. Use `internal`, `external` or `toroidal`.&#39;</span><span class="p">)</span>

    <span class="n">shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">coeffs</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">nmax</span>  <span class="c1"># replace dim of axis with nmax</span>
    <span class="n">W_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nmax</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="nb">min</span> <span class="o">=</span> <span class="n">n</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="nb">max</span> <span class="o">=</span> <span class="nb">min</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">slc1</span> <span class="o">=</span> <span class="n">coeffs</span><span class="o">.</span><span class="n">ndim</span><span class="o">*</span><span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),]</span>  <span class="c1"># index for summation</span>
        <span class="n">slc1</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="nb">min</span><span class="p">,</span> <span class="nb">max</span><span class="p">)</span>

        <span class="n">slc2</span> <span class="o">=</span> <span class="n">coeffs</span><span class="o">.</span><span class="n">ndim</span><span class="o">*</span><span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),]</span>  <span class="c1"># index for insertion into output</span>
        <span class="n">slc2</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span>

        <span class="n">W_n</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slc2</span><span class="p">)]</span> <span class="o">=</span> <span class="n">factor</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">coeffs</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slc1</span><span class="p">)]</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span>
                                               <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">W_n</span></div>


<div class="viewcode-block" id="degree_correlation"><a class="viewcode-back" href="../../functions/chaosmagpy.model_utils.degree_correlation.html#chaosmagpy.model_utils.degree_correlation">[docs]</a><span class="k">def</span> <span class="nf">degree_correlation</span><span class="p">(</span><span class="n">coeffs_1</span><span class="p">,</span> <span class="n">coeffs_2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Correlation per spherical harmonic degree between two models 1 and 2.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    coeffs_1, coeffs_2 : ndarray, shape (N,)</span>
<span class="sd">        Two sets of coefficients of equal length `N`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    C_n : ndarray, shape (nmax,)</span>
<span class="sd">        Degree correlation of the two models. There are `N = nmax(nmax+2)`</span>
<span class="sd">        coefficients.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">coeffs_1</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Only 1-D input allowed </span><span class="si">{</span><span class="n">coeffs_1</span><span class="o">.</span><span class="n">ndim</span><span class="si">}</span><span class="s1"> != 1&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">coeffs_2</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Only 1-D input allowed </span><span class="si">{</span><span class="n">coeffs_2</span><span class="o">.</span><span class="n">ndim</span><span class="si">}</span><span class="s1"> != 1&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">coeffs_1</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">coeffs_2</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;Number of coefficients is &#39;</span>
            <span class="s1">&#39;not equal (</span><span class="si">{0}</span><span class="s1"> != </span><span class="si">{1}</span><span class="s1">).&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">coeffs_1</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">coeffs_2</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>

    <span class="n">nmax</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">coeffs_1</span><span class="o">.</span><span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">C_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nmax</span><span class="p">,))</span>
    <span class="n">R_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nmax</span><span class="p">,))</span>  <span class="c1"># elements are prop. to power spectrum of coeffs_1</span>
    <span class="n">S_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nmax</span><span class="p">,))</span>  <span class="c1"># elements are prop. to power spectrum of coeffs_2</span>

    <span class="n">coeffs_12</span> <span class="o">=</span> <span class="n">coeffs_1</span><span class="o">*</span><span class="n">coeffs_2</span>

    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nmax</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="nb">min</span> <span class="o">=</span> <span class="n">n</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="nb">max</span> <span class="o">=</span> <span class="nb">min</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">R_n</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">coeffs_1</span><span class="p">[</span><span class="nb">min</span><span class="p">:</span><span class="nb">max</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">S_n</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">coeffs_2</span><span class="p">[</span><span class="nb">min</span><span class="p">:</span><span class="nb">max</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">C_n</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">coeffs_12</span><span class="p">[</span><span class="nb">min</span><span class="p">:</span><span class="nb">max</span><span class="p">])</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">R_n</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">S_n</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

    <span class="k">return</span> <span class="n">C_n</span></div>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h3><a href="../../index.html">Table of Contents</a></h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../readme.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gallery/index.html">Gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../configuration.html">Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../references.html">API References</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../license.html">License</a></li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="nav-item nav-item-0"><a href="../../index.html">ChaosMagPy 0.11 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">chaosmagpy.model_utils</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2021, Clemens Kloss.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.1.2.
    </div>
  </body>
</html>